[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "About Me",
    "section": "",
    "text": "Hopefully this helps you understand who I am and what I enjoy doing. The two tabs here are projects I did while in my undergrad and graduate school.\n\nSkills\n-Proficient in programs R, Python, and Microsoft Office Suite.\n-Fully capable of preforming independent research.\n-Able to be trained with quick turn around to train others to same high level of standard.\n\n\nEducation\n- B.A. in Economics and B.S. in Mathematics (May 2022). M.S. in Business Analytics (December 2025).\n-College courses for Mathematics were focused on statistics, regression, and applied programming.\n-College courses for Economics were focused on econometrics, and macroeconomics.\n-Research developed while at the university was a combination of above.\n-College course for Business Analytics were focused on statistical model, project management and machine learning."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Goalies.html",
    "href": "Goalies.html",
    "title": "Goalies",
    "section": "",
    "text": "This study investigates the relationship between NHL goalie salaries and team performance. Specifically, we ask whether higher-paid goalies contribute to better team outcomes, such as ranking in the top 16 teams (playoff eligibility). We examine contract values in relation to goalie performance metrics, including Wins, Save Percentage (Sv%), and Time on Ice (TOI). The goal is to identify which variables most strongly influence salary and determine whether current pay structures align with performance. We use multilevel regression analysis and interpret the significance of different predictors.\n\n\n\nIn this paper, we aim to determine whether a National Hockey League (NHL) team that allocates more money to its goal tenders (goalies) will lead to the team achieving a ranking in the top 16 at the conclusion of the season. The reason we choose the top 16 is that it is the number of teams that advance to the playoffs. While teams ranked 15th or 16th occasionally miss the playoffs due to conference seeding, we focused on the top 16 teams by overall standings. The measure of goalies is strictly the average pay per year against a team’s Cap Hit. This shows what the goalie will earn that year, regardless of bonuses. We used the average pay, rather than the goalie’s contract amount divided by the number of years the contract was signed for, to maintain consistency. Teams have player’s pay allocated to sometimes pay out different amounts each year which means that a contract of $ 10 million dollars for 5 years would seem to be $ 2 million a year but we see that some players/goalies will get $ 3 million the first year, and only $1 million in the last year. Looking at this, it seems that a team values the players/goalies more in the first year. This also leads a team to make better deals at the end of that contract, whether it would lead to resigning a contract, extension of a contract, or a trade to another team. The reverse logic is that a player/goalie who is paid the same throughout the contract (or more at the end, which is very rare), would mean the team values the player/goalie equally throughout the contracted years.\nThe variables used in this paper are Cap Hit, Wins, overall average Sv %, TOI, GP, and ranking of teams throughout each, rather than a total. We are also only looking at the last four seasons, ’21-’22, ’22-’23, ’23-’24, ’24-’25. This keeps the number of games played per season at 82, rather than accounting for the COVID-19 seasons where ’19-’20 and ’20-’21 were cut short. The tools used are mostly regression, looking at R^2. We will break down how we get there and why we choose to use certain variables at different times.\n\n\n\nFor this research, we sought to see what would lead an NHL goalie to argue for a higher pay rate. This started with seeing Igor Shesterkin, who “signed an eight-year, $ 92 million contract with the New York Rangers (Rosen, 1) this past season. This allowed him to be the highest-paid goalie in NHL history, but it still only makes him the 9th (three-way tie) highest-paid player for the next season, ’25-’26. With that, we looked into a few things. 1. What do goalies do to drive their pay? 2. What can goalies change to possibly argue for more pay? and 3. Are the fallacies in what drives goalie salaries when they sign contracts?\nWe saw through different articles and papers that one idea that comes from Ding, Cribben, Ingolfsson, and Tran at the University of Alberta looked into whether goalies get hot in the playoffs. We chose to look at the regular season rather than the playoffs, but they saw that goalies with lower Sv% should be preferred as they will turn and start to perform better. Meaning that all goalies perform to a certain average, and if they are below this, then they will at some point start to perform above this average. Also means that the average Sv% of goalies leads to wins.\nWe then saw with Luther III and Estep state that goalies in the salary cap era aren’t used for their higher performance alone, but how well they perform against their salary. They showed that recent Stanley Cup winners used a very low cap space allocated towards their goalies. With 8% or less allocated towards the position that receives the most TOI and makes up 10% of the team for the maximum number of players (18 skaters and 2 goalies in the regular season). This amount goes up to 13% post-trade deadline (20 skaters and 3 goalies) and continues into the playoffs with that format. So why does a position in hockey that seems to be one of the most critical get paid a lesser amount? A statement made famous by a football head coach is, Paul Bryant, “offense sells tickets, but defense wins championships”. This can explain the difference if a team is looking to sell tickets, as goalies very rarely score goals. But if a team is hunting for a championship, the Cup, and is willing to forgo higher scoring games, then they should look more into their defense, which starts and ends with a goalie.\n\n\n\nData were collected from NHL.com (stats), NHLPA.com (CBA and cap data), and Spotrac.com (contract details). Goalies were associated with the final team they played for each season, under the assumption that final teams absorbed the cap hit.\nSalary cap values used per season:\n\n’21-22: $ 81.5 million\n’22-23: $ 82.5 million\n’23-24 and 2024-25: $ 83.5 million\n\nThe salary floor for ’24-25 was $ 70.6 million. Minimum player salary was $ 775,000, rookie max $ 950,000, and total player max 20% of team cap (i.e., $ 17.6 million for ’24-25).\nCarey Price had the highest goalie salary ($ 10.5M), while Igor Shesterkin will earn $ 11.85 million in ’25-26.\n\n\nNot all data is good data. Each team in the NHL is allowed to have 3 goalies on the roster, while only 2 can be “dressed” for the game, meaning that they are on the ice for the game or on the bench ready to go in. The third goalie is typically playing for an affiliated team in a lower level, like the American Hockey League (AHL). In the rules of the NHL, you are allowed to pull your starting goalie and put in the backup. The starting goalie for any particular game can either be the number one goalie (typically the highest-paid) or the second goalie. The idea is that goalies cannot play all 82 games in a row. They are given breaks throughout the season, but the goalie who played the last 3-20 games will be dressed for the game(s), but still able to play if the starting goalie becomes injured or has a bad game. A goalie who is having a bad game, meaning they are getting scored on without making many saves (lower Sv%), is eligible to be pulled. There is a rule in the NHL where an Emergency Backup Goalie (EBUG) will be in the building ready to play, but not dressed, for either team, meaning the EBUG can play for an away team. An example is that an EBUG can be in the stands at a Dallas Stars game, in Dallas, and play for the Anaheim Ducks, the away team, which happened on April 29th, 2022. The EBUG procedure became a rule in the 16-’17 season, and before this, it was simply set as a team would call upon a volunteer amateur goalie. This is used when a team’s starting goalie is injured during the game, along with the backup goalie. This can also happen when the starting goalie is pulled, the second goalie becomes injured, requiring the starting goalie to be put back into the game, and then becomes injured. Injuries can range widely, but it is very rare to happen to both goalies. In fact, the EBUG process has only occurred 6 times in NHL history. Since they are EBUGs, they are not allowed to be in any sense a professional goaltender or team-paid employee, meaning they are not paid by any team, and are mostly former goalies or students. The next season of ’25-’26, there will be traveling EBUGs that will not count towards the roster limit and therefore will most likely not go against the cap hit, and there is no set pay for them. Although EBUGs got TOI, they only get $500 (yes, hundred, not thousands) for the game as a professional tryout contract. Side note, they received their jersey, which must be an awesome item for the trophy case in the man cave. This rule means that an EBUG, a goalie, can help a team receive a win; they don’t affect the salary cap for that year. So, for that fact, we removed the 3 EBUGs that took the ice during the seasons we looked at. They were Thomas Hodges for the Anaheim Ducks on April 29th, 2022, with 19 minutes and 16 seconds TOI, Matt Berlin for the Edmonton Oilers on January 28th, 2023, with 2 minutes and 26 seconds, and Jett Alexander for the Toronto Maple Leafs on April 8, 2023 with 1 minute and 10 seconds. The total is 22 minutes and 52 seconds. They do not significantly affect the data set, contributing less than 23 minutes of total ice time.\n\n\n\nLet’s first look at the cap space. We briefly went over what goalies get paid. Here is are the rankings we use. In Millions:\nMinimum = 0.075\n25th percentile = 0.78\nMedian = 1.05\n75th percentile = 3.50\nMaximum = 10.50\nThese are broken up by quantiles and are in millions of dollars. So the minimum amount of these bins is $ 750,000 per year, which is the league minimum for any player. However, we see half of the goalies get $ 1,050,000 per year. This is in the ranking of Cap Hit for players set at 531 out of 836 players as of last season, ’24-’25. Next is looking at how these bins spread across several factors. Cap hit against itself, Sv% (save percentage [saves against the number of shots taken]), Wins (overall wins), and TOI (time spent on ice). We used Sv% because this measures how good a goalie performs. The number of shots they can take per season ranges from 1 (rare) to 2,155 shots, while the number of saves ranges from 1 to 1,962. This has used a range for Sv% from 50% to 100%. Wins are used to show how well the Sv% can be used against not only cap hit but also against Sv%. These show which range of paid goalies get more wins, and which range of wins get higher Sv%. The last used is TOI, which will show if a goalie is paid more, do they spend more time on ice, and how much that will vary. It comes off as obvious that if a general manager/head coach pays a goalie more, they will be their starting goalie. Meaning that the goalie is trusted to win more games, so play them more often.\n\n\n\n\n\nThis box plot, Cap Hit vs itself, shows how the low and mid-low groupings are grouped close together. There is a big jump to mid-high and an even bigger jump to the high group. We also see some low-range outliers moving the data down and some high-range outliers moving the data up.\n\n\n\n\n\nHere we see that overall, the Sv% is evenly distributed across all four groupings for the Cap Hit. This shows that regardless of what goalies are paid, they achieve roughly a similar amount of a Sv% regardless of shots taken or saved. A few outliers exist in each group, more in the lower, and then fewer and fewer as we move up in groupings.\n\n\n\n\n\nNow we do see that higher-paid goalies do receive more wins. This is related to that you play your more trusted goalie more to either guarantee wins or in hopes of securing a win. We see general managers say that goalies who “‘stop(s) 92% of shots in of the best goalies in the world’, Tulsky said, ‘a guy who stops 91% is average’” (Kaplan page 3). This shows that paying goalies more is essentially hoping that those goalies get a 92% Sv%.\n\n\n\n\n\nNow we see that those who are getting more wins do have a range of wins from 0 to 47. That being said, the goalie that had 47 wins in one season was Connor Hellebuyck, who played 63 games in the ’24-’25 season. Now there are 48 goalies that 0 wins in any particular season, ranging from 1 to 8 games played in those seasons.\n\n\n\n\n\nLastly, we see that goalies who get paid more do play more, with TOI showing against the Cap Hit. This follows the trend we’ve been seeing. So, goalies who get paid more get more TOI, bigger Sv%, and more Wins. Let us now check which teams in the ranking are paying more for goalies.\n\n\n\n\n\nThis shows that each team in the top 16 has goalies that are in the range of Cap Hit, along with the bottom 16 teams. Just explaining that each team is attempting to achieve a better ranking while paying more or less for goalies.\n\n\n\n\n\nBreaking down now by seasons, we see that sometimes the top-ranked teams do have more goalies in the lower pay range.\nLet’s look at how goalie pay ranges throughout the seasons.\n\n\n\n\n\n\n\n\n\nHaving seen the data, let us now perform a few analyses. Starting with whether the variables we are looking at follow a normal distribution. For this, we will determine if the variables used have linear relationships, skewness from outliers, and whether we should transform the latter-mentioned models. Next will be return on investment (ROI), to show if teams are paying a fair amount on goalie salaries and getting what they ask for, more Wins, and higher Sv%. Lastly, we will create a regression model and dive deep into that.\n\n\nLet’s also examine which of these variables follow a normal distribution.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe do not see any of these variables following a normal distribution. We will check later if the residuals approximately follow a normal distribution. What matters more is if the residuals follow a normal distribution, which will be discussed later. These graphs show more about how outliers are affecting the overall data. With Sv% being the most skewed with outliers. Followed by Wins, having some. And TOI has some outliers, but less so.\n\n\n\n\n\n\n\n\nThe above graph shows that goalies that being paid less seem to have a lower Sv% overall, but those who are paid more do not have a higher Sv%. Also shows that the Sv% is densely grouped around 90% with TOI ranging wildly. We do have outliers that have lower pay, more TOI with a fairly high number of Wins, and a high Sv%.\n\n\n\n\n\nThis graph is a line for a linear model. Essentially line of best fit showing that there is a positive trend for more pay leading to a higher Sv%. We still see the TOI still ranging, but it does show that higher pay means more TOI.\n\n\n\nWe start with a linear regression of Sv% against Cap Hit and Wins against Cap Hit. We want to see that they have more positive effects than the other variables.\n\n\n\n\n\nWe see that our assumption is correct, but also see that there is not a constant variance. We will address this later.\n\n\n\n\n\nSimilar as stated last, those paid more perform better now in terms of Wins.\n\n\n\n\n\nNow, those who are paid more receive more TOI.\n\n\n\n\n\nWith this graph, the total Cap Hit that each team used per season led to a variety of wins, with a wide variety of variance. By this, we mean what each team paid for all goalies used, starting, backup, and third string (or more). We’ve highlighted the Stanley Cup winners for each season observed. The cup was used instead of the top 16; those teams had to be in the top 16. Let’s show this again by season.\n\n\n\n\n\nWe see what was expected, the teams in the top 16 are above, on, or slightly below the regression. Not one team in the bottom 16 is above. An obvious statement, but it is useful to see.\n\n\n\nLet us now change how we look at pay for goalies. Each year, as stated before, has different salary caps that each team is able to pay for their players. We will take the goalie pay and modify it to show the percentage of the salary cap for their respective teams. For example, in the ’21-’22 season, Carey Price was the highest-paid goalie at \\$ 10.5 million that year. That year, having a \\$ 81.5 million salary cap, Price received 12.88% of his team’s (Montreal Canadiens) salary cap. We hope this will show that the pay against the used variables will be better.\n\n\nThrough this model, we see that with the predictor variables (Sv%, Wins, and TOI), we see a positive trend for the predicted relationship between goalie performance and pay. The positive coefficients suggest that goalies with higher Sv%, Wins, and TOI tend to earn more money for their respective team’s salary cap. We see an increase in Sv%, by will change the Cap Hit % by \\$ `{r}b_sv_dollars\\. Similarly, another win will change their pay by`{r} b_toi_dollars`}, and another minute on ice will change their pay by`{r} beta_toi`. We start the model with an intercept with`{r} intercept`. Which leads us to the equation of $\\hat{y} = b_0 + b_1*Sv% + b_2*Wins + b_3*TOI + \\epsilon$. This is: $\\hat{y} = $`{r} intercept`+`{r} beta_sv`Sv% +`{r} beta_wins`Wins +`{r} beta_toi`TOI + $\\epsilon$. We have an $R^2$ of`{r} r2\\`, , which is the best and shows that there is a lot of noise in this model.\n\n\n\n\n\nAbove, we see the negative relationship between the predicted Cap Hit % against actual Sv%. Consequently, paying more does not lead to higher Sv%.\n\n\n\n\n\nFrom this, we can see that the more Wins there are, we predict high pay.\n\n\n\n\n\nAnd lastly, more TOI, we predict more pay.\n\n\n\nWe tested a few items: multicollinearity, autocorrelation, and heteroskedasticity. For multicollinearity, we used a variance inflation factor calculation for our predictors, and they have a value of:\\\nCap Hit off of Percentage we have `{r} vif_wins`\\\nSv% we have `{r} vif_sv_percent`\\\nand with TOI we have `{r} vif_toi_minutes`\\\nWith these values being great than 1, we do some correlation with each other.\\\nFor autocorrelation we used a Durbin-Watson (DW) test, and we have a value of `{r} dw_stat`, which is very close to 2 meaning have no evidence of autocorrelation.\\\nFor heteroskedasticity we tested this by using a Breusch-Pagan (BP) test and residual plots. For the BP test value we have `{r} bp_pval`, which means there is strong evidence to suggest heteroskedasticity. We also see this with residual plots below.\n\n\n\n\n\nWe see with these plots the following:\n*The “Residuals vs Fitted” shows that the residuals do follow a pattern, mostly at first, but we would’ve liked to see no pattern through the whole plot.\n*For the “Q-Q Residuals,” the residuals at the front and back end do not follow the diagonal line, so they do not follow a normal distribution that well.\n*With the “Scale-Location,” the line is not flat, meaning the variance is not constant.\nAnd the “Residuals vs Leverage” shows a few outliers and high-leverage points, so a few observations are influencing the model as a whole. This suggests that we should modify the model. We test the model with a t-test using robust standard errors to correct for heteroskedasticity.\nThough this we see in order of significance with p-values, TOI 0.00006, (Very Significant), Sv% 0.00809, (Significant), wins 0.35221, (Not Significant). with values being less than 0.0001, to 0.01, to 0.05 to 0.1 are the levels we see of significance. Seeing this, we are encourage to remove Wins from the model. Let us see if this is the case with a step-wise regression model.\n\n\n\nThis process tells us that we should drop Wins and Sv% as variables used in the regression. With visualization:"
  },
  {
    "objectID": "Goalies.html#abstract",
    "href": "Goalies.html#abstract",
    "title": "Goalies",
    "section": "",
    "text": "This study investigates the relationship between NHL goalie salaries and team performance. Specifically, we ask whether higher-paid goalies contribute to better team outcomes, such as ranking in the top 16 teams (playoff eligibility). We examine contract values in relation to goalie performance metrics, including Wins, Save Percentage (Sv%), and Time on Ice (TOI). The goal is to identify which variables most strongly influence salary and determine whether current pay structures align with performance. We use multilevel regression analysis and interpret the significance of different predictors."
  },
  {
    "objectID": "Goalies.html#introduction",
    "href": "Goalies.html#introduction",
    "title": "Goalies",
    "section": "",
    "text": "In this paper, we aim to determine whether a National Hockey League (NHL) team that allocates more money to its goal tenders (goalies) will lead to the team achieving a ranking in the top 16 at the conclusion of the season. The reason we choose the top 16 is that it is the number of teams that advance to the playoffs. While teams ranked 15th or 16th occasionally miss the playoffs due to conference seeding, we focused on the top 16 teams by overall standings. The measure of goalies is strictly the average pay per year against a team’s Cap Hit. This shows what the goalie will earn that year, regardless of bonuses. We used the average pay, rather than the goalie’s contract amount divided by the number of years the contract was signed for, to maintain consistency. Teams have player’s pay allocated to sometimes pay out different amounts each year which means that a contract of $ 10 million dollars for 5 years would seem to be $ 2 million a year but we see that some players/goalies will get $ 3 million the first year, and only $1 million in the last year. Looking at this, it seems that a team values the players/goalies more in the first year. This also leads a team to make better deals at the end of that contract, whether it would lead to resigning a contract, extension of a contract, or a trade to another team. The reverse logic is that a player/goalie who is paid the same throughout the contract (or more at the end, which is very rare), would mean the team values the player/goalie equally throughout the contracted years.\nThe variables used in this paper are Cap Hit, Wins, overall average Sv %, TOI, GP, and ranking of teams throughout each, rather than a total. We are also only looking at the last four seasons, ’21-’22, ’22-’23, ’23-’24, ’24-’25. This keeps the number of games played per season at 82, rather than accounting for the COVID-19 seasons where ’19-’20 and ’20-’21 were cut short. The tools used are mostly regression, looking at R^2. We will break down how we get there and why we choose to use certain variables at different times."
  },
  {
    "objectID": "Goalies.html#literature-review",
    "href": "Goalies.html#literature-review",
    "title": "Goalies",
    "section": "",
    "text": "For this research, we sought to see what would lead an NHL goalie to argue for a higher pay rate. This started with seeing Igor Shesterkin, who “signed an eight-year, $ 92 million contract with the New York Rangers (Rosen, 1) this past season. This allowed him to be the highest-paid goalie in NHL history, but it still only makes him the 9th (three-way tie) highest-paid player for the next season, ’25-’26. With that, we looked into a few things. 1. What do goalies do to drive their pay? 2. What can goalies change to possibly argue for more pay? and 3. Are the fallacies in what drives goalie salaries when they sign contracts?\nWe saw through different articles and papers that one idea that comes from Ding, Cribben, Ingolfsson, and Tran at the University of Alberta looked into whether goalies get hot in the playoffs. We chose to look at the regular season rather than the playoffs, but they saw that goalies with lower Sv% should be preferred as they will turn and start to perform better. Meaning that all goalies perform to a certain average, and if they are below this, then they will at some point start to perform above this average. Also means that the average Sv% of goalies leads to wins.\nWe then saw with Luther III and Estep state that goalies in the salary cap era aren’t used for their higher performance alone, but how well they perform against their salary. They showed that recent Stanley Cup winners used a very low cap space allocated towards their goalies. With 8% or less allocated towards the position that receives the most TOI and makes up 10% of the team for the maximum number of players (18 skaters and 2 goalies in the regular season). This amount goes up to 13% post-trade deadline (20 skaters and 3 goalies) and continues into the playoffs with that format. So why does a position in hockey that seems to be one of the most critical get paid a lesser amount? A statement made famous by a football head coach is, Paul Bryant, “offense sells tickets, but defense wins championships”. This can explain the difference if a team is looking to sell tickets, as goalies very rarely score goals. But if a team is hunting for a championship, the Cup, and is willing to forgo higher scoring games, then they should look more into their defense, which starts and ends with a goalie."
  },
  {
    "objectID": "Goalies.html#data",
    "href": "Goalies.html#data",
    "title": "Goalies",
    "section": "",
    "text": "Data were collected from NHL.com (stats), NHLPA.com (CBA and cap data), and Spotrac.com (contract details). Goalies were associated with the final team they played for each season, under the assumption that final teams absorbed the cap hit.\nSalary cap values used per season:\n\n’21-22: $ 81.5 million\n’22-23: $ 82.5 million\n’23-24 and 2024-25: $ 83.5 million\n\nThe salary floor for ’24-25 was $ 70.6 million. Minimum player salary was $ 775,000, rookie max $ 950,000, and total player max 20% of team cap (i.e., $ 17.6 million for ’24-25).\nCarey Price had the highest goalie salary ($ 10.5M), while Igor Shesterkin will earn $ 11.85 million in ’25-26.\n\n\nNot all data is good data. Each team in the NHL is allowed to have 3 goalies on the roster, while only 2 can be “dressed” for the game, meaning that they are on the ice for the game or on the bench ready to go in. The third goalie is typically playing for an affiliated team in a lower level, like the American Hockey League (AHL). In the rules of the NHL, you are allowed to pull your starting goalie and put in the backup. The starting goalie for any particular game can either be the number one goalie (typically the highest-paid) or the second goalie. The idea is that goalies cannot play all 82 games in a row. They are given breaks throughout the season, but the goalie who played the last 3-20 games will be dressed for the game(s), but still able to play if the starting goalie becomes injured or has a bad game. A goalie who is having a bad game, meaning they are getting scored on without making many saves (lower Sv%), is eligible to be pulled. There is a rule in the NHL where an Emergency Backup Goalie (EBUG) will be in the building ready to play, but not dressed, for either team, meaning the EBUG can play for an away team. An example is that an EBUG can be in the stands at a Dallas Stars game, in Dallas, and play for the Anaheim Ducks, the away team, which happened on April 29th, 2022. The EBUG procedure became a rule in the 16-’17 season, and before this, it was simply set as a team would call upon a volunteer amateur goalie. This is used when a team’s starting goalie is injured during the game, along with the backup goalie. This can also happen when the starting goalie is pulled, the second goalie becomes injured, requiring the starting goalie to be put back into the game, and then becomes injured. Injuries can range widely, but it is very rare to happen to both goalies. In fact, the EBUG process has only occurred 6 times in NHL history. Since they are EBUGs, they are not allowed to be in any sense a professional goaltender or team-paid employee, meaning they are not paid by any team, and are mostly former goalies or students. The next season of ’25-’26, there will be traveling EBUGs that will not count towards the roster limit and therefore will most likely not go against the cap hit, and there is no set pay for them. Although EBUGs got TOI, they only get $500 (yes, hundred, not thousands) for the game as a professional tryout contract. Side note, they received their jersey, which must be an awesome item for the trophy case in the man cave. This rule means that an EBUG, a goalie, can help a team receive a win; they don’t affect the salary cap for that year. So, for that fact, we removed the 3 EBUGs that took the ice during the seasons we looked at. They were Thomas Hodges for the Anaheim Ducks on April 29th, 2022, with 19 minutes and 16 seconds TOI, Matt Berlin for the Edmonton Oilers on January 28th, 2023, with 2 minutes and 26 seconds, and Jett Alexander for the Toronto Maple Leafs on April 8, 2023 with 1 minute and 10 seconds. The total is 22 minutes and 52 seconds. They do not significantly affect the data set, contributing less than 23 minutes of total ice time.\n\n\n\nLet’s first look at the cap space. We briefly went over what goalies get paid. Here is are the rankings we use. In Millions:\nMinimum = 0.075\n25th percentile = 0.78\nMedian = 1.05\n75th percentile = 3.50\nMaximum = 10.50\nThese are broken up by quantiles and are in millions of dollars. So the minimum amount of these bins is $ 750,000 per year, which is the league minimum for any player. However, we see half of the goalies get $ 1,050,000 per year. This is in the ranking of Cap Hit for players set at 531 out of 836 players as of last season, ’24-’25. Next is looking at how these bins spread across several factors. Cap hit against itself, Sv% (save percentage [saves against the number of shots taken]), Wins (overall wins), and TOI (time spent on ice). We used Sv% because this measures how good a goalie performs. The number of shots they can take per season ranges from 1 (rare) to 2,155 shots, while the number of saves ranges from 1 to 1,962. This has used a range for Sv% from 50% to 100%. Wins are used to show how well the Sv% can be used against not only cap hit but also against Sv%. These show which range of paid goalies get more wins, and which range of wins get higher Sv%. The last used is TOI, which will show if a goalie is paid more, do they spend more time on ice, and how much that will vary. It comes off as obvious that if a general manager/head coach pays a goalie more, they will be their starting goalie. Meaning that the goalie is trusted to win more games, so play them more often.\n\n\n\n\n\nThis box plot, Cap Hit vs itself, shows how the low and mid-low groupings are grouped close together. There is a big jump to mid-high and an even bigger jump to the high group. We also see some low-range outliers moving the data down and some high-range outliers moving the data up.\n\n\n\n\n\nHere we see that overall, the Sv% is evenly distributed across all four groupings for the Cap Hit. This shows that regardless of what goalies are paid, they achieve roughly a similar amount of a Sv% regardless of shots taken or saved. A few outliers exist in each group, more in the lower, and then fewer and fewer as we move up in groupings.\n\n\n\n\n\nNow we do see that higher-paid goalies do receive more wins. This is related to that you play your more trusted goalie more to either guarantee wins or in hopes of securing a win. We see general managers say that goalies who “‘stop(s) 92% of shots in of the best goalies in the world’, Tulsky said, ‘a guy who stops 91% is average’” (Kaplan page 3). This shows that paying goalies more is essentially hoping that those goalies get a 92% Sv%.\n\n\n\n\n\nNow we see that those who are getting more wins do have a range of wins from 0 to 47. That being said, the goalie that had 47 wins in one season was Connor Hellebuyck, who played 63 games in the ’24-’25 season. Now there are 48 goalies that 0 wins in any particular season, ranging from 1 to 8 games played in those seasons.\n\n\n\n\n\nLastly, we see that goalies who get paid more do play more, with TOI showing against the Cap Hit. This follows the trend we’ve been seeing. So, goalies who get paid more get more TOI, bigger Sv%, and more Wins. Let us now check which teams in the ranking are paying more for goalies.\n\n\n\n\n\nThis shows that each team in the top 16 has goalies that are in the range of Cap Hit, along with the bottom 16 teams. Just explaining that each team is attempting to achieve a better ranking while paying more or less for goalies.\n\n\n\n\n\nBreaking down now by seasons, we see that sometimes the top-ranked teams do have more goalies in the lower pay range.\nLet’s look at how goalie pay ranges throughout the seasons."
  },
  {
    "objectID": "Goalie_Salaries_VS_Rankings.html",
    "href": "Goalie_Salaries_VS_Rankings.html",
    "title": "National Hockey League Goalie Salaries and Team Ranking",
    "section": "",
    "text": "This study investigates the relationship between NHL goalie salaries and team performance. Specifically, we ask whether higher-paid goalies contribute to better team outcomes, such as ranking in the top 16 teams (playoff eligibility). We examine contract values in relation to goalie performance metrics, including Wins, Save Percentage (Sv%), and Time on Ice (TOI). The goal is to identify which variables most strongly influence salary and determine whether current pay structures align with performance. We use multilevel regression analysis and interpret the significance of different predictors.\n\n\n\nIn this paper, we aim to determine whether a National Hockey League (NHL) team that allocates more money to its goal tenders (goalies) will lead to the team achieving a ranking in the top 16 at the conclusion of the season. The reason we choose the top 16 is that it is the number of teams that advance to the playoffs. While teams ranked 15th or 16th occasionally miss the playoffs due to conference seeding, we focused on the top 16 teams by overall standings. The measure of goalies is strictly the average pay per year against a team’s Cap Hit. This shows what the goalie will earn that year, regardless of bonuses. We used the average pay, rather than the goalie’s contract amount divided by the number of years the contract was signed for, to maintain consistency. Teams have player’s pay allocated to sometimes pay out different amounts each year which means that a contract of $ 10 million dollars for 5 years would seem to be $ 2 million a year but we see that some players/goalies will get $ 3 million the first year, and only $1 million in the last year. Looking at this, it seems that a team values the players/goalies more in the first year. This also leads a team to make better deals at the end of that contract, whether it would lead to resigning a contract, extension of a contract, or a trade to another team. The reverse logic is that a player/goalie who is paid the same throughout the contract (or more at the end, which is very rare), would mean the team values the player/goalie equally throughout the contracted years. The variables used in this paper are Cap Hit, Wins, overall average Sv %, TOI, GP, and ranking of teams throughout each, rather than a total. We are also only looking at the last four seasons, ’21-’22, ’22-’23, ’23-’24, ’24-’25. This keeps the number of games played per season at 82, rather than accounting for the COVID-19 seasons where ’19-’20 and ’20-’21 were cut short. The tools used are mostly regression, looking at R^2. We will break down how we get there and why we choose to use certain variables at different times.\n\n\n\nFor this research, we sought to see what would lead an NHL goalie to argue for a higher pay rate. This started with seeing Igor Shesterkin, who “signed an eight-year, $ 92 million contract with the New York Rangers” (Rosen, 1) this past season. This allowed him to be the highest-paid goalie in NHL history, but it still only makes him the 9th (three-way tie) highest-paid player for the next season, ’25-’26. With that, we looked into a few things. 1. What do goalies do to drive their pay? 2. What can goalies change to possibly argue for more pay? 3. Are the fallacies in what drives goalie salaries when they sign contracts? We saw through different articles and papers that one idea that comes from Ding, Cribben, Ingolfsson, and Tran at the University of Alberta looked into whether goalies get hot in the playoffs. We chose to look at the regular season rather than the playoffs, but they saw that goalies with lower Sv% should be preferred as they will turn and start to perform better. Meaning that all goalies perform to a certain average, and if they are below this, then they will at some point start to perform above this average. Also means that the average Sv% of goalies leads to wins. We then saw with Luther III and Estep state that goalies in the salary cap era aren’t used for their higher performance alone, but how well they perform against their salary. They showed that recent Stanley Cup winners used a very low cap space allocated towards their goalies. With 8% or less allocated towards the position that receives the most TOI and makes up 10% of the team for the maximum number of players (18 skaters and 2 goalies in the regular season). This amount goes up to 13% post-trade deadline (20 skaters and 3 goalies) and continues into the playoffs with that format. So why does a position in hockey that seems to be one of the most critical get paid a lesser amount? A statement made famous by a football head coach is, Paul Bryant, “offense sells tickets, but defense wins championships”. This can explain the difference if a team is looking to sell tickets, as goalies very rarely score goals. But if a team is hunting for a championship, the Cup, and is willing to forgo higher scoring games, then they should look more into their defense, which starts and ends with a goalie.\n\n\n\nData were collected from NHL.com (stats), NHLPA.com (CBA and cap data), and Spotrac.com (contract details). Goalies were associated with the final team they played for each season, under the assumption that final teams absorbed the cap hit.\nSalary cap values used per season:\n*’21-22: $ 81.5 million\n*’22-23: $ 82.5 million\n*’23-24 and 2024-25: $ 83.5 million\nThe salary floor for ’24-25 was $ 70.6 million. Minimum player salary was $ 775,000, rookie max $ 950,000, and total player max 20% of team cap (i.e., $ 17.6 million for ’24-25). Carey Price had the highest goalie salary ($ 10.5M), while Igor Shesterkin will earn $ 11.85 million in ’25-26.\n\n\n\nNot all data is good data. Each team in the NHL is allowed to have 3 goalies on the roster, while only 2 can be “dressed” for the game, meaning that they are on the ice for the game or on the bench ready to go in. The third goalie is typically playing for an affiliated team in a lower level, like the American Hockey League (AHL). In the rules of the NHL, you are allowed to pull your starting goalie and put in the backup. The starting goalie for any particular game can either be the number one goalie (typically the highest-paid) or the second goalie. The idea is that goalies cannot play all 82 games in a row. They are given breaks throughout the season, but the goalie who played the last 3-20 games will be dressed for the game(s), but still able to play if the starting goalie becomes injured or has a bad game. A goalie who is having a bad game, meaning they are getting scored on without making many saves (lower Sv%), is eligible to be pulled. There is a rule in the NHL where an Emergency Backup Goalie (EBUG) will be in the building ready to play, but not dressed, for either team, meaning the EBUG can play for an away team. An example is that an EBUG can be in the stands at a Dallas Stars game, in Dallas, and play for the Anaheim Ducks, the away team, which happened on April 29th, 2022. The EBUG procedure became a rule in the 16-’17 season, and before this, it was simply set as a team would call upon a volunteer amateur goalie. This is used when a team’s starting goalie is injured during the game, along with the backup goalie. This can also happen when the starting goalie is pulled, the second goalie becomes injured, requiring the starting goalie to be put back into the game, and then becomes injured. Injuries can range widely, but it is very rare to happen to both goalies. In fact, the EBUG process has only occurred 6 times in NHL history. Since they are EBUGs, they are not allowed to be in any sense a professional goaltender or team-paid employee, meaning they are not paid by any team, and are mostly former goalies or students. The next season of ’25-’26, there will be traveling EBUGs that will not count towards the roster limit and therefore will most likely not go against the cap hit, and there is no set pay for them. Although EBUGs got TOI, they only get $500 (yes, hundred, not thousands) for the game as a professional tryout contract. Side note, they received their jersey, which must be an awesome item for the trophy case in the man cave. This rule means that an EBUG, a goalie, can help a team receive a win; they don’t affect the salary cap for that year. So, for that fact, we removed the 3 EBUGs that took the ice during the seasons we looked at. They were Thomas Hodges for the Anaheim Ducks on April 29th, 2022, with 19 minutes and 16 seconds TOI, Matt Berlin for the Edmonton Oilers on January 28th, 2023, with 2 minutes and 26 seconds, and Jett Alexander for the Toronto Maple Leafs on April 8, 2023 with 1 minute and 10 seconds. The total is 22 minutes and 52 seconds. They do not significantly affect the data set, contributing less than 23 minutes of total ice time.\n\n\n\nLet’s first look at the cap space. We briefly went over what goalies get paid. Here is are the rankings we use. In Millions:\nMinimum = 0.075\n25th percentile = 0.786875\nMedian = 1.05\n75th percentile = 3.5\nMaximum = 10.5\n\nThese are broken up by quantiles and are in millions of dollars. So the minimum amount of these bins is 750,000 dollars per year, which is the league minimum for any player. However, we see half of the goalies get 1,050,000 dollars per year. This is in the ranking of Cap Hit for players set at 531 out of 836 players as of last season, ’24-’25. Next is looking at how these bins spread across several factors. Cap hit against itself, Sv% (save percentage [saves against the number of shots taken]), Wins (overall wins), and TOI (time spent on ice). We used Sv% because this measures how good a goalie performs. The number of shots they can take per season ranges from 1 (rare) to 2,155 shots, while the number of saves ranges from 1 to 1,962. This has used a range for Sv% from 50% to 100%. Wins are used to show how well the Sv% can be used against not only cap hit but also against Sv%. These show which range of paid goalies get more wins, and which range of wins get higher Sv%. The last used is TOI, which will show if a goalie is paid more, do they spend more time on ice, and how much that will vary. It comes off as obvious that if a general manager/head coach pays a goalie more, they will be their starting goalie. Meaning that the goalie is trusted to win more games, so play them more often.\n\n\n\n\n\nThis box plot, Cap Hit vs itself, shows how the low and mid-low groupings are grouped close together. There is a big jump to mid-high and an even bigger jump to the high group. We also see some low-range outliers moving the data down and some high-range outliers moving the data up.\n\n\n\n\n\nHere we see that overall, the Sv% is evenly distributed across all four groupings for the Cap Hit. This shows that regardless of what goalies are paid, they achieve roughly a similar amount of a Sv% regardless of shots taken or saved. A few outliers exist in each group, more in the lower, and then fewer and fewer as we move up in groupings.\n\n\n\n\n\nNow we do see that higher-paid goalies do receive more wins. This is related to that you play your more trusted goalie more to either guarantee wins or in hopes of securing a win. We see general managers say that goalies who “‘stop[s] 92% of shots in of the best goalies in the world’, Tulsky said, ‘a guy who stops 91% is average’” (Kaplan page 3). This shows that paying goalies more is essentially hoping that those goalies get a 92% Sv%.\n\n\n\n\n\nNow we see that those who are getting more wins do have a range of wins from 0 to 47. That being said, the goalie that had 47 wins in one season was Connor Hellebuyck, who played 63 games in the ’24-’25 season. Now there are 48 goalies that 0 wins in any particular season, ranging from 1 to 8 games played in those seasons.\n\n\n\n\n\nLastly, we see that goalies who get paid more do play more, with TOI showing against the Cap Hit. This follows the trend we’ve been seeing. So, goalies who get paid more get more TOI, bigger Sv%, and more Wins. Let us now check which teams in the ranking are paying more for goalies.\n\n\n\n\n\nThis shows that each team in the top 16 has goalies that are in the range of Cap Hit, along with the bottom 16 teams. Just explaining that each team is attempting to achieve a better ranking while paying more or less for goalies.\n\n\n\n\n\nBreaking down now by seasons, we see that sometimes the top-ranked teams do have more goalies in the lower pay range.\nLet’s look at how goalie pay ranges throughout the seasons.\n\n\n\n\n\n\n\n\nHaving seen the data, let us now perform a few analyses. Starting with whether the variables we are looking at follow a normal distribution. For this, we will determine if the variables used have linear relationships, skewness from outliers, and whether we should transform the latter-mentioned models. Next will be return on investment (ROI), to show if teams are paying a fair amount on goalie salaries and getting what they ask for, more Wins, and higher Sv%. Lastly, we will create a regression model and dive deep into that.\n\n\nLet’s also examine which of these variables follow a normal distribution.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe do not see any of these variables following a normal distribution. We will check later if the residuals approximately follow a normal distribution. What matters more is if the residuals follow a normal distribution, which will be discussed later. These graphs show more about how outliers are affecting the overall data. With Sv% being the most skewed with outliers. Followed by Wins, having some. And TOI has some outliers, but less so.\n\n\n\n\n\n\n\n\nThe above graph shows that goalies that being paid less seem to have a lower Sv% overall, but those who are paid more do not have a higher Sv%. Also shows that the Sv% is densely grouped around 90% with TOI ranging wildly. We do have outliers that have lower pay, more TOI with a fairly high number of Wins, and a high Sv%.\n\n\n\n\n\nThis graph is a line for a linear model. Essentially line of best fit showing that there is a positive trend for more pay leading to a higher Sv%. We still see the TOI still ranging, but it does show that higher pay means more TOI.\n\n\n\nWe start with a linear regression of Sv% against Cap Hit and Wins against Cap Hit. We want to see that they have more positive effects than the other variables.\n\n\n\n\n\nWe see that our assumption is correct, but also see that there is not a constant variance. We will address this later.\n\n\n\n\n\nSimilar as stated last, those paid more perform better now in terms of Wins.\n\n\n\n\n\nNow, those who are paid more receive more TOI.\n\n\n\n\n\nWith this graph, the total Cap Hit that each team used per season led to a variety of wins, with a wide variety of variance. By this, we mean what each team paid for all goalies used, starting, backup, and third string (or more). We’ve highlighted the Stanley Cup winners for each season observed. The cup was used instead of the top 16; those teams had to be in the top 16. Let’s show this again by season.\n\n\n\n\n\nWe see what was expected, the teams in the top 16 are above, on, or slightly below the regression. Not one team in the bottom 16 is above. An obvious statement, but it is useful to see.\n\n\n\nLet us now change how we look at pay for goalies. Each year, as stated before, has different salary caps that each team is able to pay for their players. We will take the goalie pay and modify it to show the percentage of the salary cap for their respective teams. For example, in the ’21-’22 season, Carey Price was the highest-paid goalie at $ 10.5 million that year. That year, having a $ 81.5 million salary cap, Price received 12.88% of his team’s (Montreal Canadiens) salary cap. We hope this will show that the pay against the used variables will be better.\n\n\nThrough this model, we see that with the predictor variables (Sv%, Wins, and TOI), we see a positive trend for the predicted relationship between goalie performance and pay. The positive coefficients suggest that goalies with higher Sv%, Wins, and TOI tend to earn more money for their respective team’s salary cap. We see an increase in Sv%, by will change the Cap Hit % by $ rb_sv_dollars`. Similarly, another win will change their pay by 934.6522307}, and another minute on ice will change their pay by 1.1143395^{-5}. We start the model with an intercept with 0.0317817. Which leads us to the equation of \\(\\hat{y} = b_0 + b_1*Sv\\% + b_2*Wins + b_3*TOI + \\epsilon\\). This is: $ = $ 0.0317817 + -0.0272011Sv% + 2.9722564^{-4}Wins + 1.1143395^{-5}TOI + \\(\\epsilon\\). We have an \\(R^2\\) of 0.387374, , which is the best and shows that there is a lot of noise in this model.\n\n\n\n\n\nAbove, we see the negative relationship between the predicted Cap Hit % against actual Sv%. Consequently, paying more does not lead to higher Sv%.\n\n\n\n\n\nFrom this, we can see that the more Wins there are, we predict high pay.\n\n\n\n\n\nAnd lastly, more TOI, we predict more pay.\n\n\n\nWe tested a few items: multicollinearity, autocorrelation, and heteroskedasticity. For multicollinearity, we used a variance inflation factor calculation for our predictors, and they have a value of:\n\nCap Hit off of Percentage we have 8.84482\nSv% we have 1.10493\nand with TOI we have 8.71104\nWith these values being great than 1, we do some correlation with each other.\n\nFor autocorrelation we used a Durbin-Watson (DW) test, and we have a value of 1.93713, which is very close to 2 meaning have no evidence of autocorrelation.\n\nFor heteroskedasticity we tested this by using a Breusch-Pagan (BP) test and residual plots. For the BP test value we have 2^{-5}, which means there is strong evidence to suggest heteroskedasticity. We also see this with residual plots below.\n\n\n\n\n\nWe see with these plots the following:\n\n*The “Residuals vs Fitted” shows that the residuals do follow a pattern, mostly at first, but we would’ve liked to see no pattern through the whole plot.\n\n*For the “Q-Q Residuals,” the residuals at the front and back end do not follow the diagonal line, so they do not follow a normal distribution that well.\n\n*With the “Scale-Location,” the line is not flat, meaning the variance is not constant.\n\nAnd the “Residuals vs Leverage” shows a few outliers and high-leverage points, so a few observations are influencing the model as a whole. This suggests that we should modify the model. We test the model with a t-test using robust standard errors to correct for heteroskedasticity.\nThough this we see in order of significance with p-values, TOI 6^{-5}, (Very Significant), Sv% 0.00809, (Significant), wins 0.35221, (Not Significant). with values being less than 0.0001, to 0.01, to 0.05 to 0.1 are the levels we see of significance. Seeing this, we are encourage to remove Wins from the model. Let us see if this is the case with a step-wise regression model.\n\n\n\nThis process tells us that we should drop Wins and Sv% as variables used in the regression. With visualization:"
  },
  {
    "objectID": "Goalie_Salaries_VS_Rankings.html#do-higher-paid-goalies-lead-to-teams-ending-the-season-better-than-others",
    "href": "Goalie_Salaries_VS_Rankings.html#do-higher-paid-goalies-lead-to-teams-ending-the-season-better-than-others",
    "title": "National Hockey League Goalie Salaries and Team Ranking",
    "section": "",
    "text": "This study investigates the relationship between NHL goalie salaries and team performance. Specifically, we ask whether higher-paid goalies contribute to better team outcomes, such as ranking in the top 16 teams (playoff eligibility). We examine contract values in relation to goalie performance metrics, including Wins, Save Percentage (Sv%), and Time on Ice (TOI). The goal is to identify which variables most strongly influence salary and determine whether current pay structures align with performance. We use multilevel regression analysis and interpret the significance of different predictors.\n\n\n\nIn this paper, we aim to determine whether a National Hockey League (NHL) team that allocates more money to its goal tenders (goalies) will lead to the team achieving a ranking in the top 16 at the conclusion of the season. The reason we choose the top 16 is that it is the number of teams that advance to the playoffs. While teams ranked 15th or 16th occasionally miss the playoffs due to conference seeding, we focused on the top 16 teams by overall standings. The measure of goalies is strictly the average pay per year against a team’s Cap Hit. This shows what the goalie will earn that year, regardless of bonuses. We used the average pay, rather than the goalie’s contract amount divided by the number of years the contract was signed for, to maintain consistency. Teams have player’s pay allocated to sometimes pay out different amounts each year which means that a contract of $ 10 million dollars for 5 years would seem to be $ 2 million a year but we see that some players/goalies will get $ 3 million the first year, and only $1 million in the last year. Looking at this, it seems that a team values the players/goalies more in the first year. This also leads a team to make better deals at the end of that contract, whether it would lead to resigning a contract, extension of a contract, or a trade to another team. The reverse logic is that a player/goalie who is paid the same throughout the contract (or more at the end, which is very rare), would mean the team values the player/goalie equally throughout the contracted years. The variables used in this paper are Cap Hit, Wins, overall average Sv %, TOI, GP, and ranking of teams throughout each, rather than a total. We are also only looking at the last four seasons, ’21-’22, ’22-’23, ’23-’24, ’24-’25. This keeps the number of games played per season at 82, rather than accounting for the COVID-19 seasons where ’19-’20 and ’20-’21 were cut short. The tools used are mostly regression, looking at R^2. We will break down how we get there and why we choose to use certain variables at different times.\n\n\n\nFor this research, we sought to see what would lead an NHL goalie to argue for a higher pay rate. This started with seeing Igor Shesterkin, who “signed an eight-year, $ 92 million contract with the New York Rangers” (Rosen, 1) this past season. This allowed him to be the highest-paid goalie in NHL history, but it still only makes him the 9th (three-way tie) highest-paid player for the next season, ’25-’26. With that, we looked into a few things. 1. What do goalies do to drive their pay? 2. What can goalies change to possibly argue for more pay? 3. Are the fallacies in what drives goalie salaries when they sign contracts? We saw through different articles and papers that one idea that comes from Ding, Cribben, Ingolfsson, and Tran at the University of Alberta looked into whether goalies get hot in the playoffs. We chose to look at the regular season rather than the playoffs, but they saw that goalies with lower Sv% should be preferred as they will turn and start to perform better. Meaning that all goalies perform to a certain average, and if they are below this, then they will at some point start to perform above this average. Also means that the average Sv% of goalies leads to wins. We then saw with Luther III and Estep state that goalies in the salary cap era aren’t used for their higher performance alone, but how well they perform against their salary. They showed that recent Stanley Cup winners used a very low cap space allocated towards their goalies. With 8% or less allocated towards the position that receives the most TOI and makes up 10% of the team for the maximum number of players (18 skaters and 2 goalies in the regular season). This amount goes up to 13% post-trade deadline (20 skaters and 3 goalies) and continues into the playoffs with that format. So why does a position in hockey that seems to be one of the most critical get paid a lesser amount? A statement made famous by a football head coach is, Paul Bryant, “offense sells tickets, but defense wins championships”. This can explain the difference if a team is looking to sell tickets, as goalies very rarely score goals. But if a team is hunting for a championship, the Cup, and is willing to forgo higher scoring games, then they should look more into their defense, which starts and ends with a goalie.\n\n\n\nData were collected from NHL.com (stats), NHLPA.com (CBA and cap data), and Spotrac.com (contract details). Goalies were associated with the final team they played for each season, under the assumption that final teams absorbed the cap hit.\nSalary cap values used per season:\n*’21-22: $ 81.5 million\n*’22-23: $ 82.5 million\n*’23-24 and 2024-25: $ 83.5 million\nThe salary floor for ’24-25 was $ 70.6 million. Minimum player salary was $ 775,000, rookie max $ 950,000, and total player max 20% of team cap (i.e., $ 17.6 million for ’24-25). Carey Price had the highest goalie salary ($ 10.5M), while Igor Shesterkin will earn $ 11.85 million in ’25-26.\n\n\n\nNot all data is good data. Each team in the NHL is allowed to have 3 goalies on the roster, while only 2 can be “dressed” for the game, meaning that they are on the ice for the game or on the bench ready to go in. The third goalie is typically playing for an affiliated team in a lower level, like the American Hockey League (AHL). In the rules of the NHL, you are allowed to pull your starting goalie and put in the backup. The starting goalie for any particular game can either be the number one goalie (typically the highest-paid) or the second goalie. The idea is that goalies cannot play all 82 games in a row. They are given breaks throughout the season, but the goalie who played the last 3-20 games will be dressed for the game(s), but still able to play if the starting goalie becomes injured or has a bad game. A goalie who is having a bad game, meaning they are getting scored on without making many saves (lower Sv%), is eligible to be pulled. There is a rule in the NHL where an Emergency Backup Goalie (EBUG) will be in the building ready to play, but not dressed, for either team, meaning the EBUG can play for an away team. An example is that an EBUG can be in the stands at a Dallas Stars game, in Dallas, and play for the Anaheim Ducks, the away team, which happened on April 29th, 2022. The EBUG procedure became a rule in the 16-’17 season, and before this, it was simply set as a team would call upon a volunteer amateur goalie. This is used when a team’s starting goalie is injured during the game, along with the backup goalie. This can also happen when the starting goalie is pulled, the second goalie becomes injured, requiring the starting goalie to be put back into the game, and then becomes injured. Injuries can range widely, but it is very rare to happen to both goalies. In fact, the EBUG process has only occurred 6 times in NHL history. Since they are EBUGs, they are not allowed to be in any sense a professional goaltender or team-paid employee, meaning they are not paid by any team, and are mostly former goalies or students. The next season of ’25-’26, there will be traveling EBUGs that will not count towards the roster limit and therefore will most likely not go against the cap hit, and there is no set pay for them. Although EBUGs got TOI, they only get $500 (yes, hundred, not thousands) for the game as a professional tryout contract. Side note, they received their jersey, which must be an awesome item for the trophy case in the man cave. This rule means that an EBUG, a goalie, can help a team receive a win; they don’t affect the salary cap for that year. So, for that fact, we removed the 3 EBUGs that took the ice during the seasons we looked at. They were Thomas Hodges for the Anaheim Ducks on April 29th, 2022, with 19 minutes and 16 seconds TOI, Matt Berlin for the Edmonton Oilers on January 28th, 2023, with 2 minutes and 26 seconds, and Jett Alexander for the Toronto Maple Leafs on April 8, 2023 with 1 minute and 10 seconds. The total is 22 minutes and 52 seconds. They do not significantly affect the data set, contributing less than 23 minutes of total ice time.\n\n\n\nLet’s first look at the cap space. We briefly went over what goalies get paid. Here is are the rankings we use. In Millions:\nMinimum = 0.075\n25th percentile = 0.786875\nMedian = 1.05\n75th percentile = 3.5\nMaximum = 10.5\n\nThese are broken up by quantiles and are in millions of dollars. So the minimum amount of these bins is 750,000 dollars per year, which is the league minimum for any player. However, we see half of the goalies get 1,050,000 dollars per year. This is in the ranking of Cap Hit for players set at 531 out of 836 players as of last season, ’24-’25. Next is looking at how these bins spread across several factors. Cap hit against itself, Sv% (save percentage [saves against the number of shots taken]), Wins (overall wins), and TOI (time spent on ice). We used Sv% because this measures how good a goalie performs. The number of shots they can take per season ranges from 1 (rare) to 2,155 shots, while the number of saves ranges from 1 to 1,962. This has used a range for Sv% from 50% to 100%. Wins are used to show how well the Sv% can be used against not only cap hit but also against Sv%. These show which range of paid goalies get more wins, and which range of wins get higher Sv%. The last used is TOI, which will show if a goalie is paid more, do they spend more time on ice, and how much that will vary. It comes off as obvious that if a general manager/head coach pays a goalie more, they will be their starting goalie. Meaning that the goalie is trusted to win more games, so play them more often.\n\n\n\n\n\nThis box plot, Cap Hit vs itself, shows how the low and mid-low groupings are grouped close together. There is a big jump to mid-high and an even bigger jump to the high group. We also see some low-range outliers moving the data down and some high-range outliers moving the data up.\n\n\n\n\n\nHere we see that overall, the Sv% is evenly distributed across all four groupings for the Cap Hit. This shows that regardless of what goalies are paid, they achieve roughly a similar amount of a Sv% regardless of shots taken or saved. A few outliers exist in each group, more in the lower, and then fewer and fewer as we move up in groupings.\n\n\n\n\n\nNow we do see that higher-paid goalies do receive more wins. This is related to that you play your more trusted goalie more to either guarantee wins or in hopes of securing a win. We see general managers say that goalies who “‘stop[s] 92% of shots in of the best goalies in the world’, Tulsky said, ‘a guy who stops 91% is average’” (Kaplan page 3). This shows that paying goalies more is essentially hoping that those goalies get a 92% Sv%.\n\n\n\n\n\nNow we see that those who are getting more wins do have a range of wins from 0 to 47. That being said, the goalie that had 47 wins in one season was Connor Hellebuyck, who played 63 games in the ’24-’25 season. Now there are 48 goalies that 0 wins in any particular season, ranging from 1 to 8 games played in those seasons.\n\n\n\n\n\nLastly, we see that goalies who get paid more do play more, with TOI showing against the Cap Hit. This follows the trend we’ve been seeing. So, goalies who get paid more get more TOI, bigger Sv%, and more Wins. Let us now check which teams in the ranking are paying more for goalies.\n\n\n\n\n\nThis shows that each team in the top 16 has goalies that are in the range of Cap Hit, along with the bottom 16 teams. Just explaining that each team is attempting to achieve a better ranking while paying more or less for goalies.\n\n\n\n\n\nBreaking down now by seasons, we see that sometimes the top-ranked teams do have more goalies in the lower pay range.\nLet’s look at how goalie pay ranges throughout the seasons.\n\n\n\n\n\n\n\n\nHaving seen the data, let us now perform a few analyses. Starting with whether the variables we are looking at follow a normal distribution. For this, we will determine if the variables used have linear relationships, skewness from outliers, and whether we should transform the latter-mentioned models. Next will be return on investment (ROI), to show if teams are paying a fair amount on goalie salaries and getting what they ask for, more Wins, and higher Sv%. Lastly, we will create a regression model and dive deep into that.\n\n\nLet’s also examine which of these variables follow a normal distribution.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe do not see any of these variables following a normal distribution. We will check later if the residuals approximately follow a normal distribution. What matters more is if the residuals follow a normal distribution, which will be discussed later. These graphs show more about how outliers are affecting the overall data. With Sv% being the most skewed with outliers. Followed by Wins, having some. And TOI has some outliers, but less so.\n\n\n\n\n\n\n\n\nThe above graph shows that goalies that being paid less seem to have a lower Sv% overall, but those who are paid more do not have a higher Sv%. Also shows that the Sv% is densely grouped around 90% with TOI ranging wildly. We do have outliers that have lower pay, more TOI with a fairly high number of Wins, and a high Sv%.\n\n\n\n\n\nThis graph is a line for a linear model. Essentially line of best fit showing that there is a positive trend for more pay leading to a higher Sv%. We still see the TOI still ranging, but it does show that higher pay means more TOI.\n\n\n\nWe start with a linear regression of Sv% against Cap Hit and Wins against Cap Hit. We want to see that they have more positive effects than the other variables.\n\n\n\n\n\nWe see that our assumption is correct, but also see that there is not a constant variance. We will address this later.\n\n\n\n\n\nSimilar as stated last, those paid more perform better now in terms of Wins.\n\n\n\n\n\nNow, those who are paid more receive more TOI.\n\n\n\n\n\nWith this graph, the total Cap Hit that each team used per season led to a variety of wins, with a wide variety of variance. By this, we mean what each team paid for all goalies used, starting, backup, and third string (or more). We’ve highlighted the Stanley Cup winners for each season observed. The cup was used instead of the top 16; those teams had to be in the top 16. Let’s show this again by season.\n\n\n\n\n\nWe see what was expected, the teams in the top 16 are above, on, or slightly below the regression. Not one team in the bottom 16 is above. An obvious statement, but it is useful to see.\n\n\n\nLet us now change how we look at pay for goalies. Each year, as stated before, has different salary caps that each team is able to pay for their players. We will take the goalie pay and modify it to show the percentage of the salary cap for their respective teams. For example, in the ’21-’22 season, Carey Price was the highest-paid goalie at $ 10.5 million that year. That year, having a $ 81.5 million salary cap, Price received 12.88% of his team’s (Montreal Canadiens) salary cap. We hope this will show that the pay against the used variables will be better.\n\n\nThrough this model, we see that with the predictor variables (Sv%, Wins, and TOI), we see a positive trend for the predicted relationship between goalie performance and pay. The positive coefficients suggest that goalies with higher Sv%, Wins, and TOI tend to earn more money for their respective team’s salary cap. We see an increase in Sv%, by will change the Cap Hit % by $ rb_sv_dollars`. Similarly, another win will change their pay by 934.6522307}, and another minute on ice will change their pay by 1.1143395^{-5}. We start the model with an intercept with 0.0317817. Which leads us to the equation of \\(\\hat{y} = b_0 + b_1*Sv\\% + b_2*Wins + b_3*TOI + \\epsilon\\). This is: $ = $ 0.0317817 + -0.0272011Sv% + 2.9722564^{-4}Wins + 1.1143395^{-5}TOI + \\(\\epsilon\\). We have an \\(R^2\\) of 0.387374, , which is the best and shows that there is a lot of noise in this model.\n\n\n\n\n\nAbove, we see the negative relationship between the predicted Cap Hit % against actual Sv%. Consequently, paying more does not lead to higher Sv%.\n\n\n\n\n\nFrom this, we can see that the more Wins there are, we predict high pay.\n\n\n\n\n\nAnd lastly, more TOI, we predict more pay.\n\n\n\nWe tested a few items: multicollinearity, autocorrelation, and heteroskedasticity. For multicollinearity, we used a variance inflation factor calculation for our predictors, and they have a value of:\n\nCap Hit off of Percentage we have 8.84482\nSv% we have 1.10493\nand with TOI we have 8.71104\nWith these values being great than 1, we do some correlation with each other.\n\nFor autocorrelation we used a Durbin-Watson (DW) test, and we have a value of 1.93713, which is very close to 2 meaning have no evidence of autocorrelation.\n\nFor heteroskedasticity we tested this by using a Breusch-Pagan (BP) test and residual plots. For the BP test value we have 2^{-5}, which means there is strong evidence to suggest heteroskedasticity. We also see this with residual plots below.\n\n\n\n\n\nWe see with these plots the following:\n\n*The “Residuals vs Fitted” shows that the residuals do follow a pattern, mostly at first, but we would’ve liked to see no pattern through the whole plot.\n\n*For the “Q-Q Residuals,” the residuals at the front and back end do not follow the diagonal line, so they do not follow a normal distribution that well.\n\n*With the “Scale-Location,” the line is not flat, meaning the variance is not constant.\n\nAnd the “Residuals vs Leverage” shows a few outliers and high-leverage points, so a few observations are influencing the model as a whole. This suggests that we should modify the model. We test the model with a t-test using robust standard errors to correct for heteroskedasticity.\nThough this we see in order of significance with p-values, TOI 6^{-5}, (Very Significant), Sv% 0.00809, (Significant), wins 0.35221, (Not Significant). with values being less than 0.0001, to 0.01, to 0.05 to 0.1 are the levels we see of significance. Seeing this, we are encourage to remove Wins from the model. Let us see if this is the case with a step-wise regression model.\n\n\n\nThis process tells us that we should drop Wins and Sv% as variables used in the regression. With visualization:"
  },
  {
    "objectID": "Goalie_Salaries_VS_Rankings.html#conculsion",
    "href": "Goalie_Salaries_VS_Rankings.html#conculsion",
    "title": "National Hockey League Goalie Salaries and Team Ranking",
    "section": "Conculsion",
    "text": "Conculsion\nWith our results, we can say that goalies who get more time on ice should receive a greater percentage of pay against the team’s salary cap. We found this through inspection of the data, regression analysis, and finally, identified which variables are more important than others. These goalies that do receive more already tend to get more time on ice, but this shows that they should argue for more pay when their contract comes up for renewal. If a goalie starts to get more and more play time, then that should serve as evidence that they deserve more pay, regardless of wins and save percentage. We can infer this as once a team feels confident in a goalie, then they will start to shift towards playing that goalie more than others. There can be statements made that this may only occur because the starting goalie may be injured for a while or out for the season. Although this is true, that would be overlooking the many goalies that can be called up from lower-level leagues or even trades for other goalies. Hopefully, this study can provide goalies with help in the negotiations for contract signing. More time on ice should lead to more wins with a higher save percentage, granting them contracts with more pay each year.\n\n5.0 Suggest Areas of Further Research\nFurther research would include more variables in selection, i.e. does it matter which hand a goalie catches and does that lead to better performance. Can also look when a goalie gets traded and receives a pay increase, what variables led to this decision. Lastly, when a goalie receives a pay reduction, is this soley based on age in the league or are the other varaibles that could have led to this.\n\n\n6.0 Works Cited\n“2025 NHL Cap Hit Rankings.” Spotrac, www.spotrac.com/nhl/rankings/player/_/year/2025/sort/cap_total. Accessed 8 July 2025.\n“Collective Bargaining Agreement.” The PA | NHLPA.Com, 16 Sept. 2012, nhlpa.com/the-pa/cba.\nDing, Likang, et al. Do NHL Goalies Get Hot in the Playoffs? A Multilevel Logistic Regression Analysis, University of Alberta School of Business, 9 May 2024, arxiv.org/html/2102.09689v2#abstract.\nEmily KaplanNov 18, 2024. “Why Paying Goalies Is so Complicated in Today’s NHL.” ESPN, ESPN Internet Ventures, 18 Nov. 2024, www.espn.com/nhl/story/_/id/42446173/goalie-contracts-today-nhl-igor-shesterkin-jeremy-swayman.\nLuther, Robert, and Steven C. Estep. “The Goalie Paradox: Why Elite Goalies Don’t Guarantee Playoff Success and Predictions for the 2025 Stanley Cup Playoffs.” Journal of Sports & Enterainment Law, Havard Law School, 26 Apr. 2025, journals.law.harvard.edu/jsel/2025/04/the-goalie-paradox-why-elite-goalies-dont-guarantee-playoff-success-and-predictions-for-the-2025-stanley-cup-playoffs/.\n“NHL Stats.” NHL.Com, National Hockey League, www.nhl.com/stats/goalies?reportType=season&seasonFrom=20212022&seasonTo=20242025&gameType=2&page=1&pageSize=100. Accessed 8 July 2025.\nRosen, Dan. “Shesterkin Signs 8-Year, $92 Million Contract with Rangers.” NHL.Com, National Hockey League, 8 Dec. 2024, www.nhl.com/news/igor-shesterkin-signs-eight-year-contract-with-new-york-rangers#:~:text=The%20deal%20makes%20Shesterkin%20the,Canadiens%20on%20July%202%2C%202017."
  },
  {
    "objectID": "Goalie.html",
    "href": "Goalie.html",
    "title": "National Hockey League Goalie Salaries and Team Ranking",
    "section": "",
    "text": "This study investigates the relationship between NHL goalie salaries and team performance. Specifically, we ask whether higher-paid goalies contribute to better team outcomes, such as ranking in the top 16 teams (playoff eligibility). We examine contract values in relation to goalie performance metrics, including Wins, Save Percentage (Sv%), and Time on Ice (TOI). The goal is to identify which variables most strongly influence salary and determine whether current pay structures align with performance. We use multilevel regression analysis and interpret the significance of different predictors.\n\n\n\nIn this paper, we aim to determine whether a National Hockey League (NHL) team that allocates more money to its goal tenders (goalies) will lead to the team achieving a ranking in the top 16 at the conclusion of the season. The reason we choose the top 16 is that it is the number of teams that advance to the playoffs. While teams ranked 15th or 16th occasionally miss the playoffs due to conference seeding, we focused on the top 16 teams by overall standings. The measure of goalies is strictly the average pay per year against a team’s Cap Hit. This shows what the goalie will earn that year, regardless of bonuses. We used the average pay, rather than the goalie’s contract amount divided by the number of years the contract was signed for, to maintain consistency. Teams have player’s pay allocated to sometimes pay out different amounts each year which means that a contract of $ 10 million dollars for 5 years would seem to be $ 2 million a year but we see that some players/goalies will get $ 3 million the first year, and only $1 million in the last year. Looking at this, it seems that a team values the players/goalies more in the first year. This also leads a team to make better deals at the end of that contract, whether it would lead to resigning a contract, extension of a contract, or a trade to another team. The reverse logic is that a player/goalie who is paid the same throughout the contract (or more at the end, which is very rare), would mean the team values the player/goalie equally throughout the contracted years. The variables used in this paper are Cap Hit, Wins, overall average Sv %, TOI, GP, and ranking of teams throughout each, rather than a total. We are also only looking at the last four seasons, ’21-’22, ’22-’23, ’23-’24, ’24-’25. This keeps the number of games played per season at 82, rather than accounting for the COVID-19 seasons where ’19-’20 and ’20-’21 were cut short. The tools used are mostly regression, looking at R^2. We will break down how we get there and why we choose to use certain variables at different times.\n\n\n\nFor this research, we sought to see what would lead an NHL goalie to argue for a higher pay rate. This started with seeing Igor Shesterkin, who “signed an eight-year, $ 92 million contract with the New York Rangers” (Rosen, 1) this past season. This allowed him to be the highest-paid goalie in NHL history, but it still only makes him the 9th (three-way tie) highest-paid player for the next season, ’25-’26. With that, we looked into a few things. 1. What do goalies do to drive their pay? 2. What can goalies change to possibly argue for more pay? 3. Are the fallacies in what drives goalie salaries when they sign contracts? We saw through different articles and papers that one idea that comes from Ding, Cribben, Ingolfsson, and Tran at the University of Alberta looked into whether goalies get hot in the playoffs. We chose to look at the regular season rather than the playoffs, but they saw that goalies with lower Sv% should be preferred as they will turn and start to perform better. Meaning that all goalies perform to a certain average, and if they are below this, then they will at some point start to perform above this average. Also means that the average Sv% of goalies leads to wins. We then saw with Luther III and Estep state that goalies in the salary cap era aren’t used for their higher performance alone, but how well they perform against their salary. They showed that recent Stanley Cup winners used a very low cap space allocated towards their goalies. With 8% or less allocated towards the position that receives the most TOI and makes up 10% of the team for the maximum number of players (18 skaters and 2 goalies in the regular season). This amount goes up to 13% post-trade deadline (20 skaters and 3 goalies) and continues into the playoffs with that format. So why does a position in hockey that seems to be one of the most critical get paid a lesser amount? A statement made famous by a football head coach is, Paul Bryant, “offense sells tickets, but defense wins championships”. This can explain the difference if a team is looking to sell tickets, as goalies very rarely score goals. But if a team is hunting for a championship, the Cup, and is willing to forgo higher scoring games, then they should look more into their defense, which starts and ends with a goalie.\n\n\n\nData were collected from NHL.com (stats), NHLPA.com (CBA and cap data), and Spotrac.com (contract details). Goalies were associated with the final team they played for each season, under the assumption that final teams absorbed the cap hit.\nSalary cap values used per season:\n*’21-22: $ 81.5 million\n*’22-23: $ 82.5 million\n*’23-24 and 2024-25: $ 83.5 million\nThe salary floor for ’24-25 was $ 70.6 million. Minimum player salary was $ 775,000, rookie max $ 950,000, and total player max 20% of team cap (i.e., $ 17.6 million for ’24-25). Carey Price had the highest goalie salary ($ 10.5M), while Igor Shesterkin will earn $ 11.85 million in ’25-26.\n\n\n\nNot all data is good data. Each team in the NHL is allowed to have 3 goalies on the roster, while only 2 can be “dressed” for the game, meaning that they are on the ice for the game or on the bench ready to go in. The third goalie is typically playing for an affiliated team in a lower level, like the American Hockey League (AHL). In the rules of the NHL, you are allowed to pull your starting goalie and put in the backup. The starting goalie for any particular game can either be the number one goalie (typically the highest-paid) or the second goalie. The idea is that goalies cannot play all 82 games in a row. They are given breaks throughout the season, but the goalie who played the last 3-20 games will be dressed for the game(s), but still able to play if the starting goalie becomes injured or has a bad game. A goalie who is having a bad game, meaning they are getting scored on without making many saves (lower Sv%), is eligible to be pulled. There is a rule in the NHL where an Emergency Backup Goalie (EBUG) will be in the building ready to play, but not dressed, for either team, meaning the EBUG can play for an away team. An example is that an EBUG can be in the stands at a Dallas Stars game, in Dallas, and play for the Anaheim Ducks, the away team, which happened on April 29th, 2022. The EBUG procedure became a rule in the 16-’17 season, and before this, it was simply set as a team would call upon a volunteer amateur goalie. This is used when a team’s starting goalie is injured during the game, along with the backup goalie. This can also happen when the starting goalie is pulled, the second goalie becomes injured, requiring the starting goalie to be put back into the game, and then becomes injured. Injuries can range widely, but it is very rare to happen to both goalies. In fact, the EBUG process has only occurred 6 times in NHL history. Since they are EBUGs, they are not allowed to be in any sense a professional goaltender or team-paid employee, meaning they are not paid by any team, and are mostly former goalies or students. The next season of ’25-’26, there will be traveling EBUGs that will not count towards the roster limit and therefore will most likely not go against the cap hit, and there is no set pay for them. Although EBUGs got TOI, they only get $500 (yes, hundred, not thousands) for the game as a professional tryout contract. Side note, they received their jersey, which must be an awesome item for the trophy case in the man cave. This rule means that an EBUG, a goalie, can help a team receive a win; they don’t affect the salary cap for that year. So, for that fact, we removed the 3 EBUGs that took the ice during the seasons we looked at. They were Thomas Hodges for the Anaheim Ducks on April 29th, 2022, with 19 minutes and 16 seconds TOI, Matt Berlin for the Edmonton Oilers on January 28th, 2023, with 2 minutes and 26 seconds, and Jett Alexander for the Toronto Maple Leafs on April 8, 2023 with 1 minute and 10 seconds. The total is 22 minutes and 52 seconds. They do not significantly affect the data set, contributing less than 23 minutes of total ice time.\n\n\n\nLet’s first look at the cap space. We briefly went over what goalies get paid. Here is are the rankings we use. In Millions:\nMinimum = 0.075\n25th percentile = 0.786875\nMedian = 1.05\n75th percentile = 3.5\nMaximum = 10.5\n\nThese are broken up by quantiles and are in millions of dollars. So the minimum amount of these bins is 750,000 dollars per year, which is the league minimum for any player. However, we see half of the goalies get 1,050,000 dollars per year. This is in the ranking of Cap Hit for players set at 531 out of 836 players as of last season, ’24-’25. Next is looking at how these bins spread across several factors. Cap hit against itself, Sv% (save percentage [saves against the number of shots taken]), Wins (overall wins), and TOI (time spent on ice). We used Sv% because this measures how good a goalie performs. The number of shots they can take per season ranges from 1 (rare) to 2,155 shots, while the number of saves ranges from 1 to 1,962. This has used a range for Sv% from 50% to 100%. Wins are used to show how well the Sv% can be used against not only cap hit but also against Sv%. These show which range of paid goalies get more wins, and which range of wins get higher Sv%. The last used is TOI, which will show if a goalie is paid more, do they spend more time on ice, and how much that will vary. It comes off as obvious that if a general manager/head coach pays a goalie more, they will be their starting goalie. Meaning that the goalie is trusted to win more games, so play them more often.\n\n\n\n\n\nThis box plot, Cap Hit vs itself, shows how the low and mid-low groupings are grouped close together. There is a big jump to mid-high and an even bigger jump to the high group. We also see some low-range outliers moving the data down and some high-range outliers moving the data up.\n\n\n\n\n\nHere we see that overall, the Sv% is evenly distributed across all four groupings for the Cap Hit. This shows that regardless of what goalies are paid, they achieve roughly a similar amount of a Sv% regardless of shots taken or saved. A few outliers exist in each group, more in the lower, and then fewer and fewer as we move up in groupings.\n\n\n\n\n\nNow we do see that higher-paid goalies do receive more wins. This is related to that you play your more trusted goalie more to either guarantee wins or in hopes of securing a win. We see general managers say that goalies who “‘stop[s] 92% of shots in of the best goalies in the world’, Tulsky said, ‘a guy who stops 91% is average’” (Kaplan page 3). This shows that paying goalies more is essentially hoping that those goalies get a 92% Sv%.\n\n\n\n\n\nNow we see that those who are getting more wins do have a range of wins from 0 to 47. That being said, the goalie that had 47 wins in one season was Connor Hellebuyck, who played 63 games in the ’24-’25 season. Now there are 48 goalies that 0 wins in any particular season, ranging from 1 to 8 games played in those seasons.\n\n\n\n\n\nLastly, we see that goalies who get paid more do play more, with TOI showing against the Cap Hit. This follows the trend we’ve been seeing. So, goalies who get paid more get more TOI, bigger Sv%, and more Wins. Let us now check which teams in the ranking are paying more for goalies.\n\n\n\n\n\nThis shows that each team in the top 16 has goalies that are in the range of Cap Hit, along with the bottom 16 teams. Just explaining that each team is attempting to achieve a better ranking while paying more or less for goalies.\n\n\n\n\n\nBreaking down now by seasons, we see that sometimes the top-ranked teams do have more goalies in the lower pay range.\nLet’s look at how goalie pay ranges throughout the seasons.\n\n\n\n\n\n\n\n\nHaving seen the data, let us now perform a few analyses. Starting with whether the variables we are looking at follow a normal distribution. For this, we will determine if the variables used have linear relationships, skewness from outliers, and whether we should transform the latter-mentioned models. Next will be return on investment (ROI), to show if teams are paying a fair amount on goalie salaries and getting what they ask for, more Wins, and higher Sv%. Lastly, we will create a regression model and dive deep into that.\n\n\nLet’s also examine which of these variables follow a normal distribution.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe do not see any of these variables following a normal distribution. We will check later if the residuals approximately follow a normal distribution. What matters more is if the residuals follow a normal distribution, which will be discussed later. These graphs show more about how outliers are affecting the overall data. With Sv% being the most skewed with outliers. Followed by Wins, having some. And TOI has some outliers, but less so.\n\n\n\n\n\n\n\n\nThe above graph shows that goalies that being paid less seem to have a lower Sv% overall, but those who are paid more do not have a higher Sv%. Also shows that the Sv% is densely grouped around 90% with TOI ranging wildly. We do have outliers that have lower pay, more TOI with a fairly high number of Wins, and a high Sv%.\n\n\n\n\n\nThis graph is a line for a linear model. Essentially line of best fit showing that there is a positive trend for more pay leading to a higher Sv%. We still see the TOI still ranging, but it does show that higher pay means more TOI.\n\n\n\nWe start with a linear regression of Sv% against Cap Hit and Wins against Cap Hit. We want to see that they have more positive effects than the other variables.\n\n\n\n\n\nWe see that our assumption is correct, but also see that there is not a constant variance. We will address this later.\n\n\n\n\n\nSimilar as stated last, those paid more perform better now in terms of Wins.\n\n\n\n\n\nNow, those who are paid more receive more TOI.\n\n\n\n\n\nWith this graph, the total Cap Hit that each team used per season led to a variety of wins, with a wide variety of variance. By this, we mean what each team paid for all goalies used, starting, backup, and third string (or more). We’ve highlighted the Stanley Cup winners for each season observed. The cup was used instead of the top 16; those teams had to be in the top 16. Let’s show this again by season.\n\n\n\n\n\nWe see what was expected, the teams in the top 16 are above, on, or slightly below the regression. Not one team in the bottom 16 is above. An obvious statement, but it is useful to see.\n\n\n\nLet us now change how we look at pay for goalies. Each year, as stated before, has different salary caps that each team is able to pay for their players. We will take the goalie pay and modify it to show the percentage of the salary cap for their respective teams. For example, in the ’21-’22 season, Carey Price was the highest-paid goalie at $ 10.5 million that year. That year, having a $ 81.5 million salary cap, Price received 12.88% of his team’s (Montreal Canadiens) salary cap. We hope this will show that the pay against the used variables will be better.\n\n\nThrough this model, we see that with the predictor variables (Sv%, Wins, and TOI), we see a positive trend for the predicted relationship between goalie performance and pay. The positive coefficients suggest that goalies with higher Sv%, Wins, and TOI tend to earn more money for their respective team’s salary cap. We see an increase in Sv%, by will change the Cap Hit % by $ rb_sv_dollars. Similarly, another win will change their pay by{r} b_toi_dollars}, and another minute on ice will change their pay by{r} beta_toi. We start the model with an intercept with0.0317817. Which leads us to the equation of $\\hat{y} = b_0 + b_1*Sv\\% + b_2*Wins + b_3*TOI + \\epsilon$. This is: $\\hat{y} = ${r} intercept+{r} beta_svSv% +{r} beta_winsWins +{r} beta_toiTOI + $\\epsilon$. We have an $R^2$ of{r} r2`, , which is the best and shows that there is a lot of noise in this model.\n\n\n\n\n\nAbove, we see the negative relationship between the predicted Cap Hit % against actual Sv%. Consequently, paying more does not lead to higher Sv%.\n\n\n\n\n\nFrom this, we can see that the more Wins there are, we predict high pay.\n\n\n\n\n\nAnd lastly, more TOI, we predict more pay.\n\n\n\nWe tested a few items: multicollinearity, autocorrelation, and heteroskedasticity. For multicollinearity, we used a variance inflation factor calculation for our predictors, and they have a value of:\n\nCap Hit off of Percentage we have 8.84482\nSv% we have 1.10493\nand with TOI we have 8.71104\nWith these values being great than 1, we do some correlation with each other.\n\nFor autocorrelation we used a Durbin-Watson (DW) test, and we have a value of 1.93713, which is very close to 2 meaning have no evidence of autocorrelation.\n\nFor heteroskedasticity we tested this by using a Breusch-Pagan (BP) test and residual plots. For the BP test value we have 2^{-5}, which means there is strong evidence to suggest heteroskedasticity. We also see this with residual plots below.\n\n\n\n\n\nWe see with these plots the following:\n\n*The “Residuals vs Fitted” shows that the residuals do follow a pattern, mostly at first, but we would’ve liked to see no pattern through the whole plot.\n\n*For the “Q-Q Residuals,” the residuals at the front and back end do not follow the diagonal line, so they do not follow a normal distribution that well.\n\n*With the “Scale-Location,” the line is not flat, meaning the variance is not constant.\n\nAnd the “Residuals vs Leverage” shows a few outliers and high-leverage points, so a few observations are influencing the model as a whole. This suggests that we should modify the model. We test the model with a t-test using robust standard errors to correct for heteroskedasticity.\nThough this we see in order of significance with p-values, TOI 6^{-5}, (Very Significant), Sv% 0.00809, (Significant), wins 0.35221, (Not Significant). with values being less than 0.0001, to 0.01, to 0.05 to 0.1 are the levels we see of significance. Seeing this, we are encourage to remove Wins from the model. Let us see if this is the case with a step-wise regression model.\n\n\n\nThis process tells us that we should drop Wins and Sv% as variables used in the regression. With visualization:"
  },
  {
    "objectID": "Goalie.html#do-higher-paid-goalies-lead-to-teams-ending-the-season-better-than-others",
    "href": "Goalie.html#do-higher-paid-goalies-lead-to-teams-ending-the-season-better-than-others",
    "title": "National Hockey League Goalie Salaries and Team Ranking",
    "section": "",
    "text": "This study investigates the relationship between NHL goalie salaries and team performance. Specifically, we ask whether higher-paid goalies contribute to better team outcomes, such as ranking in the top 16 teams (playoff eligibility). We examine contract values in relation to goalie performance metrics, including Wins, Save Percentage (Sv%), and Time on Ice (TOI). The goal is to identify which variables most strongly influence salary and determine whether current pay structures align with performance. We use multilevel regression analysis and interpret the significance of different predictors.\n\n\n\nIn this paper, we aim to determine whether a National Hockey League (NHL) team that allocates more money to its goal tenders (goalies) will lead to the team achieving a ranking in the top 16 at the conclusion of the season. The reason we choose the top 16 is that it is the number of teams that advance to the playoffs. While teams ranked 15th or 16th occasionally miss the playoffs due to conference seeding, we focused on the top 16 teams by overall standings. The measure of goalies is strictly the average pay per year against a team’s Cap Hit. This shows what the goalie will earn that year, regardless of bonuses. We used the average pay, rather than the goalie’s contract amount divided by the number of years the contract was signed for, to maintain consistency. Teams have player’s pay allocated to sometimes pay out different amounts each year which means that a contract of $ 10 million dollars for 5 years would seem to be $ 2 million a year but we see that some players/goalies will get $ 3 million the first year, and only $1 million in the last year. Looking at this, it seems that a team values the players/goalies more in the first year. This also leads a team to make better deals at the end of that contract, whether it would lead to resigning a contract, extension of a contract, or a trade to another team. The reverse logic is that a player/goalie who is paid the same throughout the contract (or more at the end, which is very rare), would mean the team values the player/goalie equally throughout the contracted years. The variables used in this paper are Cap Hit, Wins, overall average Sv %, TOI, GP, and ranking of teams throughout each, rather than a total. We are also only looking at the last four seasons, ’21-’22, ’22-’23, ’23-’24, ’24-’25. This keeps the number of games played per season at 82, rather than accounting for the COVID-19 seasons where ’19-’20 and ’20-’21 were cut short. The tools used are mostly regression, looking at R^2. We will break down how we get there and why we choose to use certain variables at different times.\n\n\n\nFor this research, we sought to see what would lead an NHL goalie to argue for a higher pay rate. This started with seeing Igor Shesterkin, who “signed an eight-year, $ 92 million contract with the New York Rangers” (Rosen, 1) this past season. This allowed him to be the highest-paid goalie in NHL history, but it still only makes him the 9th (three-way tie) highest-paid player for the next season, ’25-’26. With that, we looked into a few things. 1. What do goalies do to drive their pay? 2. What can goalies change to possibly argue for more pay? 3. Are the fallacies in what drives goalie salaries when they sign contracts? We saw through different articles and papers that one idea that comes from Ding, Cribben, Ingolfsson, and Tran at the University of Alberta looked into whether goalies get hot in the playoffs. We chose to look at the regular season rather than the playoffs, but they saw that goalies with lower Sv% should be preferred as they will turn and start to perform better. Meaning that all goalies perform to a certain average, and if they are below this, then they will at some point start to perform above this average. Also means that the average Sv% of goalies leads to wins. We then saw with Luther III and Estep state that goalies in the salary cap era aren’t used for their higher performance alone, but how well they perform against their salary. They showed that recent Stanley Cup winners used a very low cap space allocated towards their goalies. With 8% or less allocated towards the position that receives the most TOI and makes up 10% of the team for the maximum number of players (18 skaters and 2 goalies in the regular season). This amount goes up to 13% post-trade deadline (20 skaters and 3 goalies) and continues into the playoffs with that format. So why does a position in hockey that seems to be one of the most critical get paid a lesser amount? A statement made famous by a football head coach is, Paul Bryant, “offense sells tickets, but defense wins championships”. This can explain the difference if a team is looking to sell tickets, as goalies very rarely score goals. But if a team is hunting for a championship, the Cup, and is willing to forgo higher scoring games, then they should look more into their defense, which starts and ends with a goalie.\n\n\n\nData were collected from NHL.com (stats), NHLPA.com (CBA and cap data), and Spotrac.com (contract details). Goalies were associated with the final team they played for each season, under the assumption that final teams absorbed the cap hit.\nSalary cap values used per season:\n*’21-22: $ 81.5 million\n*’22-23: $ 82.5 million\n*’23-24 and 2024-25: $ 83.5 million\nThe salary floor for ’24-25 was $ 70.6 million. Minimum player salary was $ 775,000, rookie max $ 950,000, and total player max 20% of team cap (i.e., $ 17.6 million for ’24-25). Carey Price had the highest goalie salary ($ 10.5M), while Igor Shesterkin will earn $ 11.85 million in ’25-26.\n\n\n\nNot all data is good data. Each team in the NHL is allowed to have 3 goalies on the roster, while only 2 can be “dressed” for the game, meaning that they are on the ice for the game or on the bench ready to go in. The third goalie is typically playing for an affiliated team in a lower level, like the American Hockey League (AHL). In the rules of the NHL, you are allowed to pull your starting goalie and put in the backup. The starting goalie for any particular game can either be the number one goalie (typically the highest-paid) or the second goalie. The idea is that goalies cannot play all 82 games in a row. They are given breaks throughout the season, but the goalie who played the last 3-20 games will be dressed for the game(s), but still able to play if the starting goalie becomes injured or has a bad game. A goalie who is having a bad game, meaning they are getting scored on without making many saves (lower Sv%), is eligible to be pulled. There is a rule in the NHL where an Emergency Backup Goalie (EBUG) will be in the building ready to play, but not dressed, for either team, meaning the EBUG can play for an away team. An example is that an EBUG can be in the stands at a Dallas Stars game, in Dallas, and play for the Anaheim Ducks, the away team, which happened on April 29th, 2022. The EBUG procedure became a rule in the 16-’17 season, and before this, it was simply set as a team would call upon a volunteer amateur goalie. This is used when a team’s starting goalie is injured during the game, along with the backup goalie. This can also happen when the starting goalie is pulled, the second goalie becomes injured, requiring the starting goalie to be put back into the game, and then becomes injured. Injuries can range widely, but it is very rare to happen to both goalies. In fact, the EBUG process has only occurred 6 times in NHL history. Since they are EBUGs, they are not allowed to be in any sense a professional goaltender or team-paid employee, meaning they are not paid by any team, and are mostly former goalies or students. The next season of ’25-’26, there will be traveling EBUGs that will not count towards the roster limit and therefore will most likely not go against the cap hit, and there is no set pay for them. Although EBUGs got TOI, they only get $500 (yes, hundred, not thousands) for the game as a professional tryout contract. Side note, they received their jersey, which must be an awesome item for the trophy case in the man cave. This rule means that an EBUG, a goalie, can help a team receive a win; they don’t affect the salary cap for that year. So, for that fact, we removed the 3 EBUGs that took the ice during the seasons we looked at. They were Thomas Hodges for the Anaheim Ducks on April 29th, 2022, with 19 minutes and 16 seconds TOI, Matt Berlin for the Edmonton Oilers on January 28th, 2023, with 2 minutes and 26 seconds, and Jett Alexander for the Toronto Maple Leafs on April 8, 2023 with 1 minute and 10 seconds. The total is 22 minutes and 52 seconds. They do not significantly affect the data set, contributing less than 23 minutes of total ice time.\n\n\n\nLet’s first look at the cap space. We briefly went over what goalies get paid. Here is are the rankings we use. In Millions:\nMinimum = 0.075\n25th percentile = 0.786875\nMedian = 1.05\n75th percentile = 3.5\nMaximum = 10.5\n\nThese are broken up by quantiles and are in millions of dollars. So the minimum amount of these bins is 750,000 dollars per year, which is the league minimum for any player. However, we see half of the goalies get 1,050,000 dollars per year. This is in the ranking of Cap Hit for players set at 531 out of 836 players as of last season, ’24-’25. Next is looking at how these bins spread across several factors. Cap hit against itself, Sv% (save percentage [saves against the number of shots taken]), Wins (overall wins), and TOI (time spent on ice). We used Sv% because this measures how good a goalie performs. The number of shots they can take per season ranges from 1 (rare) to 2,155 shots, while the number of saves ranges from 1 to 1,962. This has used a range for Sv% from 50% to 100%. Wins are used to show how well the Sv% can be used against not only cap hit but also against Sv%. These show which range of paid goalies get more wins, and which range of wins get higher Sv%. The last used is TOI, which will show if a goalie is paid more, do they spend more time on ice, and how much that will vary. It comes off as obvious that if a general manager/head coach pays a goalie more, they will be their starting goalie. Meaning that the goalie is trusted to win more games, so play them more often.\n\n\n\n\n\nThis box plot, Cap Hit vs itself, shows how the low and mid-low groupings are grouped close together. There is a big jump to mid-high and an even bigger jump to the high group. We also see some low-range outliers moving the data down and some high-range outliers moving the data up.\n\n\n\n\n\nHere we see that overall, the Sv% is evenly distributed across all four groupings for the Cap Hit. This shows that regardless of what goalies are paid, they achieve roughly a similar amount of a Sv% regardless of shots taken or saved. A few outliers exist in each group, more in the lower, and then fewer and fewer as we move up in groupings.\n\n\n\n\n\nNow we do see that higher-paid goalies do receive more wins. This is related to that you play your more trusted goalie more to either guarantee wins or in hopes of securing a win. We see general managers say that goalies who “‘stop[s] 92% of shots in of the best goalies in the world’, Tulsky said, ‘a guy who stops 91% is average’” (Kaplan page 3). This shows that paying goalies more is essentially hoping that those goalies get a 92% Sv%.\n\n\n\n\n\nNow we see that those who are getting more wins do have a range of wins from 0 to 47. That being said, the goalie that had 47 wins in one season was Connor Hellebuyck, who played 63 games in the ’24-’25 season. Now there are 48 goalies that 0 wins in any particular season, ranging from 1 to 8 games played in those seasons.\n\n\n\n\n\nLastly, we see that goalies who get paid more do play more, with TOI showing against the Cap Hit. This follows the trend we’ve been seeing. So, goalies who get paid more get more TOI, bigger Sv%, and more Wins. Let us now check which teams in the ranking are paying more for goalies.\n\n\n\n\n\nThis shows that each team in the top 16 has goalies that are in the range of Cap Hit, along with the bottom 16 teams. Just explaining that each team is attempting to achieve a better ranking while paying more or less for goalies.\n\n\n\n\n\nBreaking down now by seasons, we see that sometimes the top-ranked teams do have more goalies in the lower pay range.\nLet’s look at how goalie pay ranges throughout the seasons.\n\n\n\n\n\n\n\n\nHaving seen the data, let us now perform a few analyses. Starting with whether the variables we are looking at follow a normal distribution. For this, we will determine if the variables used have linear relationships, skewness from outliers, and whether we should transform the latter-mentioned models. Next will be return on investment (ROI), to show if teams are paying a fair amount on goalie salaries and getting what they ask for, more Wins, and higher Sv%. Lastly, we will create a regression model and dive deep into that.\n\n\nLet’s also examine which of these variables follow a normal distribution.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe do not see any of these variables following a normal distribution. We will check later if the residuals approximately follow a normal distribution. What matters more is if the residuals follow a normal distribution, which will be discussed later. These graphs show more about how outliers are affecting the overall data. With Sv% being the most skewed with outliers. Followed by Wins, having some. And TOI has some outliers, but less so.\n\n\n\n\n\n\n\n\nThe above graph shows that goalies that being paid less seem to have a lower Sv% overall, but those who are paid more do not have a higher Sv%. Also shows that the Sv% is densely grouped around 90% with TOI ranging wildly. We do have outliers that have lower pay, more TOI with a fairly high number of Wins, and a high Sv%.\n\n\n\n\n\nThis graph is a line for a linear model. Essentially line of best fit showing that there is a positive trend for more pay leading to a higher Sv%. We still see the TOI still ranging, but it does show that higher pay means more TOI.\n\n\n\nWe start with a linear regression of Sv% against Cap Hit and Wins against Cap Hit. We want to see that they have more positive effects than the other variables.\n\n\n\n\n\nWe see that our assumption is correct, but also see that there is not a constant variance. We will address this later.\n\n\n\n\n\nSimilar as stated last, those paid more perform better now in terms of Wins.\n\n\n\n\n\nNow, those who are paid more receive more TOI.\n\n\n\n\n\nWith this graph, the total Cap Hit that each team used per season led to a variety of wins, with a wide variety of variance. By this, we mean what each team paid for all goalies used, starting, backup, and third string (or more). We’ve highlighted the Stanley Cup winners for each season observed. The cup was used instead of the top 16; those teams had to be in the top 16. Let’s show this again by season.\n\n\n\n\n\nWe see what was expected, the teams in the top 16 are above, on, or slightly below the regression. Not one team in the bottom 16 is above. An obvious statement, but it is useful to see.\n\n\n\nLet us now change how we look at pay for goalies. Each year, as stated before, has different salary caps that each team is able to pay for their players. We will take the goalie pay and modify it to show the percentage of the salary cap for their respective teams. For example, in the ’21-’22 season, Carey Price was the highest-paid goalie at $ 10.5 million that year. That year, having a $ 81.5 million salary cap, Price received 12.88% of his team’s (Montreal Canadiens) salary cap. We hope this will show that the pay against the used variables will be better.\n\n\nThrough this model, we see that with the predictor variables (Sv%, Wins, and TOI), we see a positive trend for the predicted relationship between goalie performance and pay. The positive coefficients suggest that goalies with higher Sv%, Wins, and TOI tend to earn more money for their respective team’s salary cap. We see an increase in Sv%, by will change the Cap Hit % by $ rb_sv_dollars. Similarly, another win will change their pay by{r} b_toi_dollars}, and another minute on ice will change their pay by{r} beta_toi. We start the model with an intercept with0.0317817. Which leads us to the equation of $\\hat{y} = b_0 + b_1*Sv\\% + b_2*Wins + b_3*TOI + \\epsilon$. This is: $\\hat{y} = ${r} intercept+{r} beta_svSv% +{r} beta_winsWins +{r} beta_toiTOI + $\\epsilon$. We have an $R^2$ of{r} r2`, , which is the best and shows that there is a lot of noise in this model.\n\n\n\n\n\nAbove, we see the negative relationship between the predicted Cap Hit % against actual Sv%. Consequently, paying more does not lead to higher Sv%.\n\n\n\n\n\nFrom this, we can see that the more Wins there are, we predict high pay.\n\n\n\n\n\nAnd lastly, more TOI, we predict more pay.\n\n\n\nWe tested a few items: multicollinearity, autocorrelation, and heteroskedasticity. For multicollinearity, we used a variance inflation factor calculation for our predictors, and they have a value of:\n\nCap Hit off of Percentage we have 8.84482\nSv% we have 1.10493\nand with TOI we have 8.71104\nWith these values being great than 1, we do some correlation with each other.\n\nFor autocorrelation we used a Durbin-Watson (DW) test, and we have a value of 1.93713, which is very close to 2 meaning have no evidence of autocorrelation.\n\nFor heteroskedasticity we tested this by using a Breusch-Pagan (BP) test and residual plots. For the BP test value we have 2^{-5}, which means there is strong evidence to suggest heteroskedasticity. We also see this with residual plots below.\n\n\n\n\n\nWe see with these plots the following:\n\n*The “Residuals vs Fitted” shows that the residuals do follow a pattern, mostly at first, but we would’ve liked to see no pattern through the whole plot.\n\n*For the “Q-Q Residuals,” the residuals at the front and back end do not follow the diagonal line, so they do not follow a normal distribution that well.\n\n*With the “Scale-Location,” the line is not flat, meaning the variance is not constant.\n\nAnd the “Residuals vs Leverage” shows a few outliers and high-leverage points, so a few observations are influencing the model as a whole. This suggests that we should modify the model. We test the model with a t-test using robust standard errors to correct for heteroskedasticity.\nThough this we see in order of significance with p-values, TOI 6^{-5}, (Very Significant), Sv% 0.00809, (Significant), wins 0.35221, (Not Significant). with values being less than 0.0001, to 0.01, to 0.05 to 0.1 are the levels we see of significance. Seeing this, we are encourage to remove Wins from the model. Let us see if this is the case with a step-wise regression model.\n\n\n\nThis process tells us that we should drop Wins and Sv% as variables used in the regression. With visualization:"
  },
  {
    "objectID": "Goalie.html#conculsion",
    "href": "Goalie.html#conculsion",
    "title": "National Hockey League Goalie Salaries and Team Ranking",
    "section": "Conculsion",
    "text": "Conculsion\nWith our results, we can say that goalies who get more time on ice should receive a greater percentage of pay against the team’s salary cap. We found this through inspection of the data, regression analysis, and finally, identified which variables are more important than others. These goalies that do receive more already tend to get more time on ice, but this shows that they should argue for more pay when their contract comes up for renewal. If a goalie starts to get more and more play time, then that should serve as evidence that they deserve more pay, regardless of wins and save percentage. We can infer this as once a team feels confident in a goalie, then they will start to shift towards playing that goalie more than others. There can be statements made that this may only occur because the starting goalie may be injured for a while or out for the season. Although this is true, that would be overlooking the many goalies that can be called up from lower-level leagues or even trades for other goalies. Hopefully, this study can provide goalies with help in the negotiations for contract signing. More time on ice should lead to more wins with a higher save percentage, granting them contracts with more pay each year.\n\n5.0 Suggest Areas of Further Research\nFurther research would include more variables in selection, i.e. does it matter which hand a goalie catches and does that lead to better performance. Can also look when a goalie gets traded and receives a pay increase, what variables led to this decision. Lastly, when a goalie receives a pay reduction, is this soley based on age in the league or are the other varaibles that could have led to this.\n\n\n6.0 Works Cited\n“2025 NHL Cap Hit Rankings.” Spotrac, www.spotrac.com/nhl/rankings/player/_/year/2025/sort/cap_total. Accessed 8 July 2025.\n“Collective Bargaining Agreement.” The PA | NHLPA.Com, 16 Sept. 2012, nhlpa.com/the-pa/cba.\nDing, Likang, et al. Do NHL Goalies Get Hot in the Playoffs? A Multilevel Logistic Regression Analysis, University of Alberta School of Business, 9 May 2024, arxiv.org/html/2102.09689v2#abstract.\nEmily KaplanNov 18, 2024. “Why Paying Goalies Is so Complicated in Today’s NHL.” ESPN, ESPN Internet Ventures, 18 Nov. 2024, www.espn.com/nhl/story/_/id/42446173/goalie-contracts-today-nhl-igor-shesterkin-jeremy-swayman.\nLuther, Robert, and Steven C. Estep. “The Goalie Paradox: Why Elite Goalies Don’t Guarantee Playoff Success and Predictions for the 2025 Stanley Cup Playoffs.” Journal of Sports & Enterainment Law, Havard Law School, 26 Apr. 2025, journals.law.harvard.edu/jsel/2025/04/the-goalie-paradox-why-elite-goalies-dont-guarantee-playoff-success-and-predictions-for-the-2025-stanley-cup-playoffs/.\n“NHL Stats.” NHL.Com, National Hockey League, www.nhl.com/stats/goalies?reportType=season&seasonFrom=20212022&seasonTo=20242025&gameType=2&page=1&pageSize=100. Accessed 8 July 2025.\nRosen, Dan. “Shesterkin Signs 8-Year, $92 Million Contract with Rangers.” NHL.Com, National Hockey League, 8 Dec. 2024, www.nhl.com/news/igor-shesterkin-signs-eight-year-contract-with-new-york-rangers#:~:text=The%20deal%20makes%20Shesterkin%20the,Canadiens%20on%20July%202%2C%202017."
  },
  {
    "objectID": "Goalies.html#analysis",
    "href": "Goalies.html#analysis",
    "title": "Goalies",
    "section": "",
    "text": "Having seen the data, let us now perform a few analyses. Starting with whether the variables we are looking at follow a normal distribution. For this, we will determine if the variables used have linear relationships, skewness from outliers, and whether we should transform the latter-mentioned models. Next will be return on investment (ROI), to show if teams are paying a fair amount on goalie salaries and getting what they ask for, more Wins, and higher Sv%. Lastly, we will create a regression model and dive deep into that.\n\n\nLet’s also examine which of these variables follow a normal distribution.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe do not see any of these variables following a normal distribution. We will check later if the residuals approximately follow a normal distribution. What matters more is if the residuals follow a normal distribution, which will be discussed later. These graphs show more about how outliers are affecting the overall data. With Sv% being the most skewed with outliers. Followed by Wins, having some. And TOI has some outliers, but less so.\n\n\n\n\n\n\n\n\nThe above graph shows that goalies that being paid less seem to have a lower Sv% overall, but those who are paid more do not have a higher Sv%. Also shows that the Sv% is densely grouped around 90% with TOI ranging wildly. We do have outliers that have lower pay, more TOI with a fairly high number of Wins, and a high Sv%.\n\n\n\n\n\nThis graph is a line for a linear model. Essentially line of best fit showing that there is a positive trend for more pay leading to a higher Sv%. We still see the TOI still ranging, but it does show that higher pay means more TOI.\n\n\n\nWe start with a linear regression of Sv% against Cap Hit and Wins against Cap Hit. We want to see that they have more positive effects than the other variables.\n\n\n\n\n\nWe see that our assumption is correct, but also see that there is not a constant variance. We will address this later.\n\n\n\n\n\nSimilar as stated last, those paid more perform better now in terms of Wins.\n\n\n\n\n\nNow, those who are paid more receive more TOI.\n\n\n\n\n\nWith this graph, the total Cap Hit that each team used per season led to a variety of wins, with a wide variety of variance. By this, we mean what each team paid for all goalies used, starting, backup, and third string (or more). We’ve highlighted the Stanley Cup winners for each season observed. The cup was used instead of the top 16; those teams had to be in the top 16. Let’s show this again by season.\n\n\n\n\n\nWe see what was expected, the teams in the top 16 are above, on, or slightly below the regression. Not one team in the bottom 16 is above. An obvious statement, but it is useful to see.\n\n\n\nLet us now change how we look at pay for goalies. Each year, as stated before, has different salary caps that each team is able to pay for their players. We will take the goalie pay and modify it to show the percentage of the salary cap for their respective teams. For example, in the ’21-’22 season, Carey Price was the highest-paid goalie at \\$ 10.5 million that year. That year, having a \\$ 81.5 million salary cap, Price received 12.88% of his team’s (Montreal Canadiens) salary cap. We hope this will show that the pay against the used variables will be better.\n\n\nThrough this model, we see that with the predictor variables (Sv%, Wins, and TOI), we see a positive trend for the predicted relationship between goalie performance and pay. The positive coefficients suggest that goalies with higher Sv%, Wins, and TOI tend to earn more money for their respective team’s salary cap. We see an increase in Sv%, by will change the Cap Hit % by \\$ `{r}b_sv_dollars\\. Similarly, another win will change their pay by`{r} b_toi_dollars`}, and another minute on ice will change their pay by`{r} beta_toi`. We start the model with an intercept with`{r} intercept`. Which leads us to the equation of $\\hat{y} = b_0 + b_1*Sv% + b_2*Wins + b_3*TOI + \\epsilon$. This is: $\\hat{y} = $`{r} intercept`+`{r} beta_sv`Sv% +`{r} beta_wins`Wins +`{r} beta_toi`TOI + $\\epsilon$. We have an $R^2$ of`{r} r2\\`, , which is the best and shows that there is a lot of noise in this model.\n\n\n\n\n\nAbove, we see the negative relationship between the predicted Cap Hit % against actual Sv%. Consequently, paying more does not lead to higher Sv%.\n\n\n\n\n\nFrom this, we can see that the more Wins there are, we predict high pay.\n\n\n\n\n\nAnd lastly, more TOI, we predict more pay.\n\n\n\nWe tested a few items: multicollinearity, autocorrelation, and heteroskedasticity. For multicollinearity, we used a variance inflation factor calculation for our predictors, and they have a value of:\\\nCap Hit off of Percentage we have `{r} vif_wins`\\\nSv% we have `{r} vif_sv_percent`\\\nand with TOI we have `{r} vif_toi_minutes`\\\nWith these values being great than 1, we do some correlation with each other.\\\nFor autocorrelation we used a Durbin-Watson (DW) test, and we have a value of `{r} dw_stat`, which is very close to 2 meaning have no evidence of autocorrelation.\\\nFor heteroskedasticity we tested this by using a Breusch-Pagan (BP) test and residual plots. For the BP test value we have `{r} bp_pval`, which means there is strong evidence to suggest heteroskedasticity. We also see this with residual plots below.\n\n\n\n\n\nWe see with these plots the following:\n*The “Residuals vs Fitted” shows that the residuals do follow a pattern, mostly at first, but we would’ve liked to see no pattern through the whole plot.\n*For the “Q-Q Residuals,” the residuals at the front and back end do not follow the diagonal line, so they do not follow a normal distribution that well.\n*With the “Scale-Location,” the line is not flat, meaning the variance is not constant.\nAnd the “Residuals vs Leverage” shows a few outliers and high-leverage points, so a few observations are influencing the model as a whole. This suggests that we should modify the model. We test the model with a t-test using robust standard errors to correct for heteroskedasticity.\nThough this we see in order of significance with p-values, TOI 0.00006, (Very Significant), Sv% 0.00809, (Significant), wins 0.35221, (Not Significant). with values being less than 0.0001, to 0.01, to 0.05 to 0.1 are the levels we see of significance. Seeing this, we are encourage to remove Wins from the model. Let us see if this is the case with a step-wise regression model.\n\n\n\nThis process tells us that we should drop Wins and Sv% as variables used in the regression. With visualization:"
  },
  {
    "objectID": "Goalies.html#suggest-areas-of-further-research",
    "href": "Goalies.html#suggest-areas-of-further-research",
    "title": "Goalies",
    "section": "5.1 Suggest Areas of Further Research",
    "text": "5.1 Suggest Areas of Further Research\nFurther research would include more variables in selection, i.e. does it matter which hand a goalie catches and does that lead to better performance. Can also look when a goalie gets traded and receives a pay increase."
  },
  {
    "objectID": "ChainPulse.html",
    "href": "ChainPulse.html",
    "title": "Chain Pulse",
    "section": "",
    "text": "Decentralization of the Cryptocurrency  dy/dx on the Ethereum Blockchain\nCryptocurrency exchanges heavily emphasize being a “decentralized finance,” in that all transactions of cryptocurrencies are made between two individuals without requiring a central intermediary. However, recent studies have expressed doubt about the decentralized nature of cryptocurrency. In this paper, we study the Euler crypto token (in addition to a previous study done over the AAVE token) to conclude that, although there are some centralized components within the network of transactions, trends across multiple tokens still indicate a decentralized nature to the network.\n#1 Introduction\nCryptocurrency prides itself on being a truly decentralized finance, meaning transactions can happen between any two individuals, or more, without the need of a central intermediary. In our lives, the best example of an intermediary is a bank. With the U.S. dollar, transactions are normally approved by a bank, meaning most exchanges of money go through a central point; the majority of transactions are between a person and a bank. Cryptocurrency is different in that transactions are made entirely between individuals, with no central intermediary. These transactions are recorded on a blockchain, which is essentially a virtual ledger. Our project is inspired by a previous paper written by Ziqiao Ao, Gergely Horvath, and Luyao Zhang, titled “Is Decentralized Finance Really Decentralized? A Social Network Analysis of the AAVE Protocol on the Ethereum Blockchain”. The paper studies the AAVE token, and attempts to argue that cryptocurrency is not fully decentralized as it claims to be. In this project, we will expand on the studies done in this original paper, with the following goals:"
  },
  {
    "objectID": "ChainPulse.html#general-approach",
    "href": "ChainPulse.html#general-approach",
    "title": "Chain Pulse",
    "section": "1.1 General Approach",
    "text": "1.1 General Approach\nThis notebook take the approach of taking the networks for the Euler token and re-framing the data into simpler, more readable outputs to better explain the idea of the centralization for the tokens. A quote to describe the idea used is\n“core-periphery structure in its simplest form refers to a partition of a network into two groups of nodes called core and periphery, where core nodes are densely interconnected (i.e., adjacent), and peripheral nodes are adjacent to the core nodes but not to other peripheral nodes”.[2]\nIf a token is to be described as being a central network we would see our graphs consist of core nodes, while a decentralized network would consist of periphery nodes.\nCore-periphery pairs are defined to have the properties of:\n\\[\nA^*=A^*_{ij}=(x_i+x_j-x_ix_j)\\delta(c_i,c_j)\n\\] We see \\(x_i=1\\) for core nodes and \\(x_i=0\\) for peripheral nodes. The index of the core-peripheral pair to which node \\(i\\) belongs to is represented by \\(c_i(1 \\leq c_i \\leq C)\\). The following properties are treated like axioms here.\n\n\nEvery core node is adjacent to every other core node.\n\n\nEvery core node is adjacent to all corresponding peripheral nodes.\n\n\nEvery peripheral node is not adjacent to any other peripheral node.\n\n\nLastly, there are no edges between different idealized core-periphery pairs. \\([3, 4]\\)\n\n\nWhen computing you want \\(c_i,x_i \\in(1 \\leq i \\leq N)\\) not be maximized comparatively between \\(A\\) and \\(A*\\). This is shown by: \\[Q^{cp}_{config} = \\frac{1}{2M} \\sum_{i=1}^N\\sum_{j=1}^N A_{ij}A_{ij}^* - Ε [\\frac{1}{2M} \\sum_{i=1}^N \\sum_{j=1}^{conf}(1-A_{ij}^*)]\\] Using a configuration model where the expected number of edges between nodes \\(i\\) and \\(j\\) can be represented by \\(Ε[A_{ij}^{conf}]=\\frac{d_id_j}{2M}\\)."
  },
  {
    "objectID": "ChainPulse.html#seeing-the-tokens-raw-form-of-a-network-for-the-months-of-june-through-august-3-continuous-months.",
    "href": "ChainPulse.html#seeing-the-tokens-raw-form-of-a-network-for-the-months-of-june-through-august-3-continuous-months.",
    "title": "Chain Pulse",
    "section": "3.1 Seeing the token’s raw form of a network for the months of June through August, 3 continuous months.",
    "text": "3.1 Seeing the token’s raw form of a network for the months of June through August, 3 continuous months.\n\n\nCollecting matplotlib==3.5.1\n  Using cached matplotlib-3.5.1.tar.gz (35.3 MB)\n  Preparing metadata (setup.py): started\n  Preparing metadata (setup.py): finished with status 'done'\nRequirement already satisfied: cycler&gt;=0.10 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib==3.5.1) (0.11.0)\nRequirement already satisfied: fonttools&gt;=4.22.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib==3.5.1) (4.51.0)\nRequirement already satisfied: kiwisolver&gt;=1.0.1 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib==3.5.1) (1.4.4)\nRequirement already satisfied: numpy&gt;=1.17 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib==3.5.1) (1.26.4)\nRequirement already satisfied: packaging&gt;=20.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib==3.5.1) (24.1)\nRequirement already satisfied: pillow&gt;=6.2.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib==3.5.1) (10.4.0)\nRequirement already satisfied: pyparsing&gt;=2.2.1 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib==3.5.1) (3.1.2)\nRequirement already satisfied: python-dateutil&gt;=2.7 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib==3.5.1) (2.9.0.post0)\nRequirement already satisfied: six&gt;=1.5 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from python-dateutil&gt;=2.7-&gt;matplotlib==3.5.1) (1.16.0)\nBuilding wheels for collected packages: matplotlib\n  Building wheel for matplotlib (setup.py): started\n  Building wheel for matplotlib (setup.py): finished with status 'error'\n  Running setup.py clean for matplotlib\nFailed to build matplotlib\nRequirement already satisfied: scipy in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (1.16.0)\nRequirement already satisfied: networkx in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (3.5)\nRequirement already satisfied: numpy&lt;2.6,&gt;=1.25.2 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from scipy) (1.26.4)\nRequirement already satisfied: cpnet in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (0.0.21)\nRequirement already satisfied: networkx&gt;=2.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from cpnet) (3.5)\nRequirement already satisfied: numpy&gt;=1.16.5 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from cpnet) (1.26.4)\nRequirement already satisfied: simanneal&gt;=0.4.2 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from cpnet) (0.5.0)\nRequirement already satisfied: scipy&gt;=1.5.2 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from cpnet) (1.16.0)\nRequirement already satisfied: numba&gt;=0.50.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from cpnet) (0.60.0)\nRequirement already satisfied: joblib&gt;=0.16.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from cpnet) (1.4.2)\nRequirement already satisfied: plotly&gt;=4.10.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from cpnet) (5.24.1)\nRequirement already satisfied: seaborn&gt;=0.11.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from cpnet) (0.13.2)\nRequirement already satisfied: pandas&gt;=1.1.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from cpnet) (2.2.2)\nRequirement already satisfied: tqdm&gt;=4.49.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from cpnet) (4.66.5)\nRequirement already satisfied: llvmlite&lt;0.44,&gt;=0.43.0dev0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from numba&gt;=0.50.0-&gt;cpnet) (0.43.0)\nRequirement already satisfied: python-dateutil&gt;=2.8.2 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from pandas&gt;=1.1.0-&gt;cpnet) (2.9.0.post0)\nRequirement already satisfied: pytz&gt;=2020.1 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from pandas&gt;=1.1.0-&gt;cpnet) (2024.1)\nRequirement already satisfied: tzdata&gt;=2022.7 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from pandas&gt;=1.1.0-&gt;cpnet) (2023.3)\nRequirement already satisfied: tenacity&gt;=6.2.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from plotly&gt;=4.10.0-&gt;cpnet) (8.2.3)\nRequirement already satisfied: packaging in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from plotly&gt;=4.10.0-&gt;cpnet) (24.1)\nRequirement already satisfied: matplotlib!=3.6.1,&gt;=3.4 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from seaborn&gt;=0.11.0-&gt;cpnet) (3.9.2)\nRequirement already satisfied: colorama in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from tqdm&gt;=4.49.0-&gt;cpnet) (0.4.6)\nRequirement already satisfied: contourpy&gt;=1.0.1 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib!=3.6.1,&gt;=3.4-&gt;seaborn&gt;=0.11.0-&gt;cpnet) (1.2.0)\nRequirement already satisfied: cycler&gt;=0.10 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib!=3.6.1,&gt;=3.4-&gt;seaborn&gt;=0.11.0-&gt;cpnet) (0.11.0)\nRequirement already satisfied: fonttools&gt;=4.22.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib!=3.6.1,&gt;=3.4-&gt;seaborn&gt;=0.11.0-&gt;cpnet) (4.51.0)\nRequirement already satisfied: kiwisolver&gt;=1.3.1 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib!=3.6.1,&gt;=3.4-&gt;seaborn&gt;=0.11.0-&gt;cpnet) (1.4.4)\nRequirement already satisfied: pillow&gt;=8 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib!=3.6.1,&gt;=3.4-&gt;seaborn&gt;=0.11.0-&gt;cpnet) (10.4.0)\nRequirement already satisfied: pyparsing&gt;=2.3.1 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib!=3.6.1,&gt;=3.4-&gt;seaborn&gt;=0.11.0-&gt;cpnet) (3.1.2)\nRequirement already satisfied: six&gt;=1.5 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from python-dateutil&gt;=2.8.2-&gt;pandas&gt;=1.1.0-&gt;cpnet) (1.16.0)\nThe libraries used are: matplotlib (verison 3.5.1), scipy, networkx, cpnet, numpy, pandas, os, time, zipfile, tqdm, \ncommunity.community_louvain, random, requests, json, and datetime.\n\n\nWARNING: Ignoring invalid distribution ~umpy (C:\\Users\\Orin Crouse\\anaconda3\\Lib\\site-packages)\n  error: subprocess-exited-with-error\n  \n  × python setup.py bdist_wheel did not run successfully.\n  │ exit code: 1\n  ╰─&gt; [606 lines of output]\n      C:\\Users\\Orin Crouse\\AppData\\Local\\Temp\\pip-install-tp0c5tlr\\matplotlib_463d11644bdb435abff0370bf85e7c32\\setup.py:70: SetuptoolsDeprecationWarning: The test command is disabled and references to it are deprecated.\n      !!\n      \n              ********************************************************************************\n              Please remove any references to `setuptools.command.test` in all supported versions of the affected package.\n      \n              This deprecation is overdue, please update your project and remove deprecated\n              calls to avoid build errors in the future.\n              ********************************************************************************\n      \n      !!\n        class NoopTestCommand(setuptools.command.test.test):\n      \n      Edit mplsetup.cfg to change the build options; suppress output with --quiet.\n      \n      BUILDING MATPLOTLIB\n            python: yes [3.12.7 | packaged by Anaconda, Inc. | (main, Oct  4 2024,\n                        13:17:27) [MSC v.1929 64 bit (AMD64)]]\n          platform: yes [win32]\n             tests: no  [skipping due to configuration]\n            macosx: no  [Mac OS-X only]\n      \n      C:\\Users\\Orin Crouse\\anaconda3\\Lib\\site-packages\\setuptools\\__init__.py:94: _DeprecatedInstaller: setuptools.installer and fetch_build_eggs are deprecated.\n      !!\n      \n              ********************************************************************************\n              Requirements should be satisfied by a PEP 517 installer.\n              If you are using pip, you can try `pip install --use-pep517`.\n              ********************************************************************************\n      \n      !!\n        dist.fetch_build_eggs(dist.setup_requires)\n      [07/15/25 16:58:01] WARNING  toml section missing       pyproject_reading.py:42\n                                   'pyproject.toml does not\n                                   contain a\n                                   tool.setuptools_scm\n                                   section'\n                                   Traceback (most recent\n                                   call last):\n                                     File \"c:\\users\\orin\n                                   crouse\\appdata\\local\\temp\\\n                                   pip-install-tp0c5tlr\\matpl\n                                   otlib_463d11644bdb435abff0\n                                   370bf85e7c32\\.eggs\\setupto\n                                   ols_scm-8.3.1-py3.12.egg\\s\n                                   etuptools_scm\\_integration\n                                   \\pyproject_reading.py\",\n                                   line 36, in read_pyproject\n                                       section =\n                                   defn.get(\"tool\",\n                                   {})[tool_name]\n                                                 ~~~~~~~~~~~~\n                                   ~~~~~~~~^^^^^^^^^^^\n                                   KeyError: 'setuptools_scm'\n      c:\\users\\orin crouse\\appdata\\local\\temp\\pip-install-tp0c5tlr\\matplotlib_463d11644bdb435abff0370bf85e7c32\\.eggs\\setuptools_scm-8.3.1-py3.12.egg\\setuptools_scm\\git.py:310: UserWarning: git archive did not support describe output\n        warnings.warn(\"git archive did not support describe output\")\n      C:\\Users\\Orin Crouse\\anaconda3\\Lib\\site-packages\\setuptools\\dist.py:655: SetuptoolsDeprecationWarning: The namespace_packages parameter is deprecated.\n      !!\n      \n              ********************************************************************************\n              Please replace its usage with implicit namespaces (PEP 420).\n      \n              See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages for details.\n              ********************************************************************************\n      \n      !!\n        ep.load()(self, ep.name, value)\n      running bdist_wheel\n      running build\n      running build_py\n      creating build\\lib.win-amd64-cpython-312\n      copying lib\\pylab.py -&gt; build\\lib.win-amd64-cpython-312\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\afm.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\animation.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\artist.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\axis.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\backend_bases.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\backend_managers.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\backend_tools.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\bezier.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\blocking_input.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\category.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\cm.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\collections.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\colorbar.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\colors.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\container.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\contour.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\dates.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\docstring.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\dviread.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\figure.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\fontconfig_pattern.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\font_manager.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\gridspec.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\hatch.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\image.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\legend.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\legend_handler.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\lines.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\markers.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\mathtext.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\mlab.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\offsetbox.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\patches.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\path.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\patheffects.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\pylab.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\pyplot.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\quiver.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\rcsetup.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\sankey.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\scale.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\spines.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\stackplot.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\streamplot.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\table.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\texmanager.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\text.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\textpath.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\ticker.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\tight_bbox.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\tight_layout.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\transforms.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\type1font.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\units.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\widgets.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_animation_data.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_blocking_input.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_cm.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_cm_listed.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_color_data.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_constrained_layout.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_enums.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_internal_utils.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_layoutgrid.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_mathtext.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_mathtext_data.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_pylab_helpers.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_text_helpers.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_version.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      creating build\\lib.win-amd64-cpython-312\\mpl_toolkits\n      copying lib\\mpl_toolkits\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\axes\n      copying lib\\matplotlib\\axes\\_axes.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\axes\n      copying lib\\matplotlib\\axes\\_base.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\axes\n      copying lib\\matplotlib\\axes\\_secondary_axes.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\axes\n      copying lib\\matplotlib\\axes\\_subplots.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\axes\n      copying lib\\matplotlib\\axes\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\axes\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_agg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_cairo.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_gtk3.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_gtk3agg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_gtk3cairo.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_gtk4.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_gtk4agg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_gtk4cairo.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_macosx.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_mixed.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_nbagg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_pdf.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_pgf.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_ps.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_qt.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_qt5.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_qt5agg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_qt5cairo.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_qtagg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_qtcairo.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_svg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_template.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_tkagg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_tkcairo.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_webagg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_webagg_core.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_wx.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_wxagg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_wxcairo.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\qt_compat.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\_backend_gtk.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\_backend_pdf_ps.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\_backend_tk.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\cbook\n      copying lib\\matplotlib\\cbook\\deprecation.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\cbook\n      copying lib\\matplotlib\\cbook\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\cbook\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\projections\n      copying lib\\matplotlib\\projections\\geo.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\projections\n      copying lib\\matplotlib\\projections\\polar.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\projections\n      copying lib\\matplotlib\\projections\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\projections\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\sphinxext\n      copying lib\\matplotlib\\sphinxext\\mathmpl.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\sphinxext\n      copying lib\\matplotlib\\sphinxext\\plot_directive.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\sphinxext\n      copying lib\\matplotlib\\sphinxext\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\sphinxext\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\style\n      copying lib\\matplotlib\\style\\core.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\style\n      copying lib\\matplotlib\\style\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\style\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\testing\n      copying lib\\matplotlib\\testing\\compare.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\n      copying lib\\matplotlib\\testing\\conftest.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\n      copying lib\\matplotlib\\testing\\decorators.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\n      copying lib\\matplotlib\\testing\\exceptions.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\n      copying lib\\matplotlib\\testing\\widgets.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\n      copying lib\\matplotlib\\testing\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\conftest.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_afm.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_agg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_agg_filter.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_animation.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_api.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_arrow_patches.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_artist.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_axes.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backends_interactive.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_bases.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_cairo.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_gtk3.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_macosx.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_nbagg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_pdf.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_pgf.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_ps.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_qt.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_svg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_tk.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_tools.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_webagg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_basic.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_bbox_tight.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_category.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_cbook.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_collections.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_colorbar.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_colors.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_compare_images.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_constrainedlayout.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_container.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_contour.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_cycles.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_dates.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_determinism.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_dviread.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_figure.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_fontconfig_pattern.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_font_manager.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_getattr.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_gridspec.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_image.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_legend.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_lines.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_marker.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_mathtext.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_matplotlib.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_mlab.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_offsetbox.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_patches.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_path.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_patheffects.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_pickle.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_png.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_polar.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_preprocess_data.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_pyplot.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_quiver.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_rcparams.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_sankey.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_scale.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_simplification.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_skew.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_sphinxext.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_spines.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_streamplot.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_style.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_subplots.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_table.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_testing.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_texmanager.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_text.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_ticker.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_tightlayout.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_transforms.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_triangulation.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_ttconv.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_type1font.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_units.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_usetex.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_widgets.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\tri\n      copying lib\\matplotlib\\tri\\triangulation.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tri\n      copying lib\\matplotlib\\tri\\tricontour.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tri\n      copying lib\\matplotlib\\tri\\trifinder.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tri\n      copying lib\\matplotlib\\tri\\triinterpolate.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tri\n      copying lib\\matplotlib\\tri\\tripcolor.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tri\n      copying lib\\matplotlib\\tri\\triplot.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tri\n      copying lib\\matplotlib\\tri\\trirefine.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tri\n      copying lib\\matplotlib\\tri\\tritools.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tri\n      copying lib\\matplotlib\\tri\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tri\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\_api\n      copying lib\\matplotlib\\_api\\deprecation.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\_api\n      copying lib\\matplotlib\\_api\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\_api\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\qt_editor\n      copying lib\\matplotlib\\backends\\qt_editor\\figureoptions.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\qt_editor\n      copying lib\\matplotlib\\backends\\qt_editor\\_formlayout.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\qt_editor\n      copying lib\\matplotlib\\backends\\qt_editor\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\qt_editor\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\testing\\jpl_units\n      copying lib\\matplotlib\\testing\\jpl_units\\Duration.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\\jpl_units\n      copying lib\\matplotlib\\testing\\jpl_units\\Epoch.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\\jpl_units\n      copying lib\\matplotlib\\testing\\jpl_units\\EpochConverter.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\\jpl_units\n      copying lib\\matplotlib\\testing\\jpl_units\\StrConverter.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\\jpl_units\n      copying lib\\matplotlib\\testing\\jpl_units\\UnitDbl.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\\jpl_units\n      copying lib\\matplotlib\\testing\\jpl_units\\UnitDblConverter.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\\jpl_units\n      copying lib\\matplotlib\\testing\\jpl_units\\UnitDblFormatter.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\\jpl_units\n      copying lib\\matplotlib\\testing\\jpl_units\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\\jpl_units\n      creating build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\anchored_artists.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\angle_helper.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\axes_divider.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\axes_grid.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\axes_rgb.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\axes_size.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\axislines.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\axisline_style.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\axis_artist.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\clip_path.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\floating_axes.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\grid_finder.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\grid_helper_curvelinear.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\inset_locator.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\parasite_axes.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      creating build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid1\n      copying lib\\mpl_toolkits\\axes_grid1\\anchored_artists.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid1\n      copying lib\\mpl_toolkits\\axes_grid1\\axes_divider.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid1\n      copying lib\\mpl_toolkits\\axes_grid1\\axes_grid.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid1\n      copying lib\\mpl_toolkits\\axes_grid1\\axes_rgb.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid1\n      copying lib\\mpl_toolkits\\axes_grid1\\axes_size.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid1\n      copying lib\\mpl_toolkits\\axes_grid1\\inset_locator.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid1\n      copying lib\\mpl_toolkits\\axes_grid1\\mpl_axes.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid1\n      copying lib\\mpl_toolkits\\axes_grid1\\parasite_axes.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid1\n      copying lib\\mpl_toolkits\\axes_grid1\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid1\n      creating build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\angle_helper.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\axes_divider.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\axes_grid.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\axes_rgb.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\axislines.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\axisline_style.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\axis_artist.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\clip_path.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\floating_axes.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\grid_finder.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\grid_helper_curvelinear.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\parasite_axes.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      creating build\\lib.win-amd64-cpython-312\\mpl_toolkits\\mplot3d\n      copying lib\\mpl_toolkits\\mplot3d\\art3d.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\mplot3d\n      copying lib\\mpl_toolkits\\mplot3d\\axes3d.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\mplot3d\n      copying lib\\mpl_toolkits\\mplot3d\\axis3d.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\mplot3d\n      copying lib\\mpl_toolkits\\mplot3d\\proj3d.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\mplot3d\n      copying lib\\mpl_toolkits\\mplot3d\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\mplot3d\n      creating build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\conftest.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\test_axes_grid.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\test_axes_grid1.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\test_axisartist_angle_helper.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\test_axisartist_axislines.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\test_axisartist_axis_artist.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\test_axisartist_clip_path.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\test_axisartist_floating_axes.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\test_axisartist_grid_finder.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\test_axisartist_grid_helper_curvelinear.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\test_mplot3d.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\matplotlib.pdf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\subplots-symbolic.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Courier-BoldOblique.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\n      copying lib\\matplotlib\\backends\\web_backend\\.eslintrc.js -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXNonUni.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\\axes_grid\n      copying lib\\matplotlib\\mpl-data\\sample_data\\axes_grid\\bivariate_normal.npy -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\\axes_grid\n      copying lib\\matplotlib\\mpl-data\\images\\forward.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\zoom_to_rect_large.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-notebook.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\images\\filesave.pdf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\cmex10.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXGeneral.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\phvr8an.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSerif-Bold.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\images\\matplotlib.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\sample_data\\msft.csv -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\stylelib\\bmh.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXSizThreeSymReg.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\cmtt10.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-poster.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-pastel.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-whitegrid.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\phvro8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\images\\hand.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\stylelib\\classic.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\plot_directive\n      copying lib\\matplotlib\\mpl-data\\plot_directive\\plot_directive.css -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\plot_directive\n      copying lib\\matplotlib\\mpl-data\\sample_data\\jacksboro_fault_dem.npz -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pbkl8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-talk.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\stylelib\\_classic_test_patch.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\images\\back_large.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\cmsy10.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-dark-palette.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\images\\forward.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pbkdi8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pncri8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\ZapfDingbats.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\images\\move.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSerif.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\images\\matplotlib_large.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\sample_data\\grace_hopper.jpg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\images\\qt4_editor_options.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\subplots_large.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pplbi8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\LICENSE_STIX -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXGeneralItalic.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\backends\\web_backend\\.prettierrc -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\n      copying lib\\matplotlib\\mpl-data\\images\\filesave.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\putb8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\\js\n      copying lib\\matplotlib\\backends\\web_backend\\js\\nbagg_mpl.js -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\\js\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pncb8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\images\\subplots.pdf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\sample_data\\embedding_in_wx3.xrc -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\stylelib\\Solarize_Light2.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\images\\forward_large.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\cmr10.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\images\\zoom_to_rect.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\sample_data\\eeg.dat -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\images\\hand.pdf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXSizThreeSymBol.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\phvb8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXSizOneSymReg.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pagk8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\backends\\web_backend\\package.json -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSans-Bold.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\images\\zoom_to_rect-symbolic.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\help.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\qt4_editor_options.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\stylelib\\tableau-colorblind10.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\matplotlibrc -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\phvlo8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\images\\filesave_large.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\cmtt10.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Times-BoldItalic.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\cmss10.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSans-Oblique.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pcrbo8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\backends\\web_backend\\single_figure.html -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\n      copying lib\\matplotlib\\backends\\web_backend\\js\\mpl.js -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\\js\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\phvl8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\sample_data\\goog.npz -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Times-Roman.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSansMono-BoldOblique.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\images\\home-symbolic.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-muted.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\backends\\web_backend\\nbagg_uat.ipynb -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\n      copying lib\\matplotlib\\mpl-data\\stylelib\\_mpl-gallery.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\ptmr8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-darkgrid.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\images\\move.pdf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-deep.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\cmsy10.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\images\\back-symbolic.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-white.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXSizTwoSymReg.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\sample_data\\s1045.ima.gz -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXNonUniBolIta.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\images\\filesave.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\sample_data\\topobathy.npz -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\LICENSE_DEJAVU -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSansMono-Oblique.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\cmb10.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\images\\help.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pplr8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\stylelib\\fast.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pcrro8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSerif-BoldItalic.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\images\\home_large.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\stylelib\\fivethirtyeight.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\images\\filesave-symbolic.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\cmmi10.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\images\\forward-symbolic.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\subplots.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSansMono.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\backends\\web_backend\\all_figures.html -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\phvbo8an.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-paper.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Helvetica-Oblique.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXSizTwoSymBol.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\sample_data\\membrane.dat -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\images\\move.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\putr8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Courier.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\\css\n      copying lib\\matplotlib\\backends\\web_backend\\css\\fbm.css -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\\css\n      copying lib\\matplotlib\\backends\\web_backend\\css\\boilerplate.css -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\\css\n      copying lib\\matplotlib\\backends\\web_backend\\css\\mpl.css -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\\css\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\phvr8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\putri8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\images\\matplotlib_128.ppm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXNonUniBol.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pbkd8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\kpsewhich.lua -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pzdr.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Courier-Oblique.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\cmr10.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\images\\move-symbolic.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\phvbo8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\stylelib\\dark_background.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\backends\\web_backend\\.prettierignore -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\n      copying lib\\matplotlib\\mpl-data\\images\\help-symbolic.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\help_large.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pcrr8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Times-Bold.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\ptmb8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\stylelib\\_mpl-gallery-nogrid.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSans-BoldOblique.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSerifDisplay.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\sample_data\\data_x_x2_x3.csv -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\images\\hand.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\help.pdf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\zoom_to_rect.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\putbi8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSansDisplay.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-bright.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\images\\home.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\sample_data\\percent_bachelors_degrees_women_usa.csv -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-dark.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\backends\\web_backend\\css\\page.css -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\\css\n      copying lib\\matplotlib\\backends\\web_backend\\ipython_inline_figure.html -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pbkli8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\phvb8an.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\backends\\web_backend\\js\\mpl_tornado.js -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\\js\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pagdo8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Helvetica-Bold.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXGeneralBolIta.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\images\\qt4_editor_options.pdf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\subplots.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\back.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\back.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\qt4_editor_options_large.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pcrb8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\ptmri8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSansMono-Bold.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pplri8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pzcmi8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXSizFourSymBol.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXNonUniIta.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\ptmbi8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSans.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\stylelib\\grayscale.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\images\\back.pdf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\phvro8an.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\images\\move_large.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\cmmi10.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSerif-Italic.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXGeneralBol.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\sample_data\\logo2.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Symbol.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\images\\forward.pdf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\home.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\cmex10.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\psyr.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\sample_data\\README.txt -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\stylelib\\ggplot.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-colorblind.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Helvetica.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXSizFourSymReg.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\readme.txt -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Courier-Bold.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXSizOneSymBol.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pncbi8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\images\\matplotlib.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\sample_data\\Minduka_Present_Blue_Pack.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\images\\home.pdf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pagd8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pagko8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pncr8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pplb8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Times-Italic.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Helvetica-BoldOblique.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXSizFiveSymReg.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\images\\zoom_to_rect.pdf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-ticks.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      running build_ext\n      Extracting /project/freetype/freetype2/2.6.1/freetype-2.6.1.tar.gz\n      Building freetype in build\\freetype-2.6.1\n      error: Microsoft Visual C++ 14.0 or greater is required. Get it with \"Microsoft C++ Build Tools\": https://visualstudio.microsoft.com/visual-cpp-build-tools/\n      [end of output]\n  \n  note: This error originates from a subprocess, and is likely not a problem with pip.\n  ERROR: Failed building wheel for matplotlib\nERROR: ERROR: Failed to build installable wheels for some pyproject.toml based projects (matplotlib)\nWARNING: Ignoring invalid distribution ~umpy (C:\\Users\\Orin Crouse\\anaconda3\\Lib\\site-packages)\nWARNING: Ignoring invalid distribution ~umpy (C:\\Users\\Orin Crouse\\anaconda3\\Lib\\site-packages)\nWARNING: Ignoring invalid distribution ~umpy (C:\\Users\\Orin Crouse\\anaconda3\\Lib\\site-packages)\nWARNING: Ignoring invalid distribution ~umpy (C:\\Users\\Orin Crouse\\anaconda3\\Lib\\site-packages)\nWARNING: Ignoring invalid distribution ~umpy (C:\\Users\\Orin Crouse\\anaconda3\\Lib\\site-packages)\nWARNING: Ignoring invalid distribution ~umpy (C:\\Users\\Orin Crouse\\anaconda3\\Lib\\site-packages)\n\n\n\n\n11372 Number Transactions for the entire data set\n\n\n\n\n\n\n\n5485 Number Transactions for June\n\n\n\n\n\n\n\n\n\n\nConstruction of the continuous core-periphery structure using the Borgatti-Everett Algorithm.\n\n\n\n\n\nWe continue with the Kojaku-Masda Algorithm to see a similar approach, but better given colors….\n\n\n\n\n\n\n\nAverage Neighbors to Cores 1.0"
  },
  {
    "objectID": "ChainPulse.html#breakdown",
    "href": "ChainPulse.html#breakdown",
    "title": "Chain Pulse",
    "section": "3.2 Breakdown",
    "text": "3.2 Breakdown\nNumber of Components: We expect a smaller number of componenets to indicate a more centralized network. The number of components is fairly random with an exception toward the beginning of the recorded data.\nGiant Component Size Ratio: A larger giant component size ratio indicates a more centralized network. In our data, the giant component ratio starts high (suggesting more centralization early on), then becomes random, similar to the number of components.\nModulatiry: A smaller modularity score suggests a more centralized network. Modularity for the Ether token starts low, but quickly rises, and stays fairly stable past day 15. This indicates a more centralized network in early days that becomes decentralized and stays decentralized after a couple of weeks. However, while the modularity for Euler settles around 0.6, the modularity for the AAVE token (found in the original paper) settles around 0.8 before dropping down to 0.7, a possible indication that AAVE is more decentralized than Euler.\nStandard Deviation of Degree Centrality: A higher standard deviation suggests a more centralized network. Standard deviation for Euler starts high but quickly falls by day five, where is stays steady. Like the modularity scores, this suggests a more centralized network early on that quickly becomes and stays decentralized."
  },
  {
    "objectID": "Goalies.html#data-sorting",
    "href": "Goalies.html#data-sorting",
    "title": "Goalies",
    "section": "3.1 Data sorting",
    "text": "3.1 Data sorting\nNot all data is good data. Each team in the NHL is allowed to have 3 goalies on the roster, while only 2 can be “dressed” for the game, meaning that they are on the ice for the game or on the bench ready to go in. The third goalie is typically playing for an affiliated team in a lower level, like the American Hockey League (AHL). In the rules of the NHL, you are allowed to pull your starting goalie and put in the backup. The starting goalie for any particular game can either be the number one goalie (typically the highest-paid) or the second goalie. The idea is that goalies cannot play all 82 games in a row. They are given breaks throughout the season, but the goalie who played the last 3-20 games will be dressed for the game(s), but still able to play if the starting goalie becomes injured or has a bad game. A goalie who is having a bad game, meaning they are getting scored on without making many saves (lower Sv%), is eligible to be pulled. There is a rule in the NHL where an Emergency Backup Goalie (EBUG) will be in the building ready to play, but not dressed, for either team, meaning the EBUG can play for an away team. An example is that an EBUG can be in the stands at a Dallas Stars game, in Dallas, and play for the Anaheim Ducks, the away team, which happened on April 29th, 2022. The EBUG procedure became a rule in the 16-’17 season, and before this, it was simply set as a team would call upon a volunteer amateur goalie. This is used when a team’s starting goalie is injured during the game, along with the backup goalie. This can also happen when the starting goalie is pulled, the second goalie becomes injured, requiring the starting goalie to be put back into the game, and then becomes injured. Injuries can range widely, but it is very rare to happen to both goalies. In fact, the EBUG process has only occurred 6 times in NHL history. Since they are EBUGs, they are not allowed to be in any sense a professional goaltender or team-paid employee, meaning they are not paid by any team, and are mostly former goalies or students. The next season of ’25-’26, there will be traveling EBUGs that will not count towards the roster limit and therefore will most likely not go against the cap hit, and there is no set pay for them. Although EBUGs got TOI, they only get $500 (yes, hundred, not thousands) for the game as a professional tryout contract. Side note, they received their jersey, which must be an awesome item for the trophy case in the man cave. This rule means that an EBUG, a goalie, can help a team receive a win; they don’t affect the salary cap for that year. So, for that fact, we removed the 3 EBUGs that took the ice during the seasons we looked at. They were Thomas Hodges for the Anaheim Ducks on April 29th, 2022, with 19 minutes and 16 seconds TOI, Matt Berlin for the Edmonton Oilers on January 28th, 2023, with 2 minutes and 26 seconds, and Jett Alexander for the Toronto Maple Leafs on April 8, 2023 with 1 minute and 10 seconds. The total is 22 minutes and 52 seconds. They do not significantly affect the data set, contributing less than 23 minutes of total ice time. While the range of TOI through the four seasons ranges from 1,336 minutes to 1,607 minutes and the average is 5,975 minutes. So 23 minutes minutes no longer in the data set will not change the change."
  },
  {
    "objectID": "Goalies.html#data-inspection",
    "href": "Goalies.html#data-inspection",
    "title": "Goalies",
    "section": "3.2 Data Inspection",
    "text": "3.2 Data Inspection\nLet’s first look at the cap space. We briefly went over what goalies get paid. Here is are the rankings we use, and the median for each bin.\nBin 1 (Low) = $758,333\nBin 2 (Mid-Low) = $910,000\nBin 3 (Mid-High) = $2,187,500\nBin 4 (High) = $5,000,000\nThese are broken up by quantiles. So the minimum amount of these bins is $750,000 per year, which is the league minimum for any player. However, we see half of the goalies get at least $1,050,000 per year. This is in the ranking of Cap Hit for players set at 531 out of 836 players as of last season, ’24-’25. Next is looking at how these bins spread across several factors. Cap hit against itself, Sv%, Wins, and TOI. We used Sv% because this measures how good a goalie performs. The number of shots they can take per season ranges from 1 (rare) to 2,155 shots, while the number of saves ranges from 1 to 1,962. This has used a range for Sv% from 50% to 100%, but the average is 89%. Wins are used to show how well the Sv% can be used against not only cap hit but also against Sv%. These show which range of paid goalies get more wins, and which range of wins get higher Sv%. The last used is TOI, which will show if a goalie is paid more, do they spend more time on ice, and how much that will vary. It comes off as obvious that if a general manager/head coach pays a goalie more, they will be their starting goalie. Meaning that the goalie is trusted to win more games, so play them more often.\n\n\n\n\n\nThis box plot, Cap Hit vs itself, shows how the low and mid-low groupings are grouped close together. There is a big jump to mid-high and an even bigger jump to the high group. We also see some low-range outliers moving the data down and some high-range outliers moving the data up.\n\n\n\n\n\nHere we see that overall, the Sv% is evenly distributed across all four groupings for the Cap Hit. This shows that regardless of what goalies are paid, they achieve roughly a similar amount of a Sv% regardless of shots taken or saved. A few outliers exist in each group, more in the lower, and then fewer and fewer as we move up in groupings.\n\n\n\n\n\nNow we do see that higher-paid goalies do receive more wins. This is related to that you play your more trusted goalie more to either guarantee wins or in hopes of securing a win. We see general managers say that goalies who “‘stop(s) 92% of shots in of the best goalies in the world’, Tulsky said, ‘a guy who stops 91% is average’” (Kaplan page 3). This shows that paying goalies more is essentially hoping that those goalies get a 92% Sv%.\n\n\n\n\n\nNow, we see that goalies who get paid more do play more, with TOI showing against the Cap Hit. This follows the trend we’ve been seeing. So, goalies who get paid more get more TOI, bigger Sv%, and more Wins. Let us now check which teams in the ranking are paying more for goalies.\n\n\n\n\n\nLastly, we see that those who are getting more wins do have a range of wins from 0 to 47. That being said, the goalie that had 47 wins in one season was Connor Hellebuyck, who played 63 games in the ’24-’25 season. Now there are 48 goalies that 0 wins in any particular season, ranging from 1 to 8 games played in those seasons.\n\n\n\n\n\nThis shows that each team in the top 16 has goalies that are in the range of Cap Hit, along with the bottom 16 teams. Just explaining that each team is attempting to achieve a better ranking while paying more or less for goalies.\n\n\n\n\n\nBreaking down now by seasons, we see that sometimes the top-ranked teams do have more goalies in the lower pay range.\nLet’s look at how goalie pay ranges throughout the seasons."
  },
  {
    "objectID": "Goalies.html#analysis-on-normal-distributions",
    "href": "Goalies.html#analysis-on-normal-distributions",
    "title": "Goalies",
    "section": "4.1 Analysis on Normal Distributions",
    "text": "4.1 Analysis on Normal Distributions\nLet’s also examine which of these variables follow a normal distribution.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe do not see any of these variables following a normal distribution. We will check later if the residuals approximately follow a normal distribution. What matters more is if the residuals follow a normal distribution, which will be discussed later. These graphs show more about how outliers are affecting the overall data. With Sv% being the most skewed with outliers. Followed by Wins, having some. And TOI has some outliers, but less so."
  },
  {
    "objectID": "Goalies.html#analysis-for-return-on-investment",
    "href": "Goalies.html#analysis-for-return-on-investment",
    "title": "Goalies",
    "section": "4.2 Analysis for Return on Investment",
    "text": "4.2 Analysis for Return on Investment\n\n\n\n\n\nThe above graph shows that goalies that being paid less seem to have a lower Sv% overall, but those who are paid more do not have a higher Sv%. Also shows that the Sv% is densely grouped around 90% with TOI ranging wildly. We do have outliers that have lower pay, more TOI with a fairly high number of Wins, and a high Sv%.\n\n\n\n\n\nThis graph is a line for a linear model. Essentially line of best fit showing that there is a positive trend for more pay leading to a higher Sv%. We still see the TOI still ranging, but it does show that higher pay means more TOI."
  },
  {
    "objectID": "Goalies.html#regression-modeling",
    "href": "Goalies.html#regression-modeling",
    "title": "Goalies",
    "section": "4.3 Regression Modeling",
    "text": "4.3 Regression Modeling\nWe start with a linear regression of Sv% against Cap Hit and Wins against Cap Hit. We want to see that they have more positive effects than the other variables.\n\n\n\n\n\nWe see that our assumption is correct, but also see that there is not a constant variance. We will address this later.\n\n\n\n\n\nSimilar as stated last, those paid more perform better now in terms of Wins.\n\n\n\n\n\nNow, those who are paid more receive more TOI.\n\n\n\n\n\nWith this graph, the total Cap Hit that each team used per season led to a variety of wins, with a wide variety of variance. By this, we mean what each team paid for all goalies used, starting, backup, and third string (or more). We’ve highlighted the Stanley Cup winners for each season observed. The cup was used instead of the top 16; those teams had to be in the top 16. Let’s show this again by season.\n\n\n\n\n\nWe see what was expected, the teams in the top 16 are above, on, or slightly below the regression. Not one team in the bottom 16 is above. An obvious statement, but it is useful to see."
  },
  {
    "objectID": "Goalies.html#regression-for-cap-hit-against-salary-cap.",
    "href": "Goalies.html#regression-for-cap-hit-against-salary-cap.",
    "title": "Goalies",
    "section": "4.3 Regression for Cap Hit against Salary Cap.",
    "text": "4.3 Regression for Cap Hit against Salary Cap.\nLet us now change how we look at pay for goalies. Each year, as stated before, has different salary caps that each team is able to pay for their players. We will take the goalie pay and modify it to show the percentage of the salary cap for their respective teams. For example, in the ‘21-’22 season, Carey Price was the highest-paid goalie at $10.5 million that year. That year, having a $81.5 million salary cap, Price received 12.88% of his team’s (Montreal Canadians) salary cap. We hope this will show that the pay against the used variables will be better. Here are the updated box plots now using the goalies’ cap hit as a percentage of that seasons salary cap per team.\n\n\n\n\n\nWe see these plots did not change but much, and at face value, are the same. Now we will use these to show prediction models.\n\n4.3.1 Prediction Regression Model\nThrough this model, we see that with the predictor variables (Sv%, Wins, and TOI), we see a positive trend for the predicted relationship between goalie performance and pay. The positive coefficients suggest that goalies with higher Sv%, Wins, and TOI tend to earn more money for their respective team’s salary cap. We see an increase of 1 in Sv%, by will change the Cap Hit % by $-2,284,189. Similarly, another Win will change their pay by 2,4929.8, and another minute of TOI change their pay by $934.65. We start the model with an intercept with $0.03. Which leads us to the equation of \\(\\hat{y} = b_0 + b_1*Sv\\% + b_2*Wins + b_3*TOI + \\epsilon\\). This is: \\(\\hat{y} = 2,665,690 - 2,281,489* Sv\\%+ 24,929.8* Wins + 934.65 * TOI + \\epsilon\\). We have an \\(R^2\\) of` 0.387, which is the best but shows that there is a lot of noise in this model.\nAlso the p-value for each variable is, Sv%=0.138, Wins=0.251, and TOI=0.0000797. As a rule, any p-value over 0.05 means that variable is not significant. So we really only want TOI. We will get into that later.\n\n\n\n\n\nAbove, we see the negative relationship between the predicted Cap Hit % against actual Sv%. Consequently, paying more does not lead to higher Sv%.\n\n\n\n\n\nFrom this, we can see that the more Wins there are, we predict high pay.\n\n\n\n\n\nAnd lastly, more TOI, we predict more pay. And we can see that this plot has more of a linear relationship, showing us that the p-value plays more here.\n\n\n4.3.2 Test Model for Potential Problems\nWe tested a few items: multicollinearity, autocorrelation, and heteroskedasticity. For multicollinearity, we used a variance inflation factor calculation for our predictors, and they have a value of:\\\nCap Hit off of Percentage we have 8.45\nSv% we have 1.10\nand with TOI we have 8.71\nWith these values being great than 1, we do some correlation with each other.\nFor autocorrelation we used a Durbin-Watson (DW) test, and we have a value of 1.94, which is very close to 2 meaning have no evidence of autocorrelation.\nFor heteroskedasticity we tested this by using a Breusch-Pagan (BP) test and residual plots. For the BP test value we have 0.0002, which means there is strong evidence to suggest heteroskedasticity. We also see this with residual plots below.\n\n\n\n\n\nWe see with these plots the following:\n*The “Residuals vs Fitted” shows that the residuals do follow a pattern, mostly at first, but we would’ve liked to see no pattern through the whole plot.\n*For the “Q-Q Residuals,” the residuals at the front and back end do not follow the diagonal line, so they do not follow a normal distribution that well.\n*With the “Scale-Location,” the line is not flat, meaning the variance is not constant.\nAnd the “Residuals vs Leverage” shows a few outliers and high-leverage points, so a few observations are influencing the model as a whole. This suggests that we should modify the model. We test the model with a t-test using robust standard errors to correct for heteroskedasticity.\nThough this we see in order of significance with p-values, TOI 0.00006, (Very Significant), Sv% 0.00809, (Significant), wins 0.35221, (Not Significant). with values being less than 0.0001, to 0.01, to 0.05 to 0.1 are the levels we see of significance. Seeing this, we are encourage to remove Wins from the model. Let us see if this is the case with a step-wise regression model.\n\n\n4.3.3 Step-Wise Regression\nThis process tells us that we should drop Wins and Sv% as variables used in the regression. With visualization:\n\n\n\n\n\n\n\n4.3.4 Regression with Only TOI against Cap Hit\n\n\n\n\n\n\n\n\n\n\nWithout loss of generality, we these above plots are ran against using only TOI to predict Cap Hit. Just as one point we have an \\(R^2\\) of 0.387 which is the same but we now have an intercept of 633,525 a beta variable of 1,136 for TOI. So the same amount of noise but overall we see that this explains better."
  },
  {
    "objectID": "Crypto.html",
    "href": "Crypto.html",
    "title": "Crypto",
    "section": "",
    "text": "Decentralization of the Cryptocurrency  dy/dx on the Ethereum Blockchain\nCryptocurrency exchanges heavily emphasize being a “decentralized finance,” in that all transactions of cryptocurrencies are made between two individuals without requiring a central intermediary. However, recent studies have expressed doubt about the decentralized nature of cryptocurrency. In this paper, we study the Euler crypto token (in addition to a previous study done over the AAVE token) to conclude that, although there are some centralized components within the network of transactions, trends across multiple tokens still indicate a decentralized nature to the network.\n#1 Introduction\nCryptocurrency prides itself on being a truly decentralized finance, meaning transactions can happen between any two individuals, or more, without the need of a central intermediary. In our lives, the best example of an intermediary is a bank. With the U.S. dollar, transactions are normally approved by a bank, meaning most exchanges of money go through a central point; the majority of transactions are between a person and a bank. Cryptocurrency is different in that transactions are made entirely between individuals, with no central intermediary. These transactions are recorded on a blockchain, which is essentially a virtual ledger. Our project is inspired by a previous paper written by Ziqiao Ao, Gergely Horvath, and Luyao Zhang, titled “Is Decentralized Finance Really Decentralized? A Social Network Analysis of the AAVE Protocol on the Ethereum Blockchain”. The paper studies the AAVE token, and attempts to argue that cryptocurrency is not fully decentralized as it claims to be. In this project, we will expand on the studies done in this original paper, with the following goals:"
  },
  {
    "objectID": "Crypto.html#general-approach",
    "href": "Crypto.html#general-approach",
    "title": "Crypto",
    "section": "1.1 General Approach",
    "text": "1.1 General Approach\nThis notebook take the approach of taking the networks for the Euler token and re-framing the data into simpler, more readable outputs to better explain the idea of the centralization for the tokens. A quote to describe the idea used is\n“core-periphery structure in its simplest form refers to a partition of a network into two groups of nodes called core and periphery, where core nodes are densely interconnected (i.e., adjacent), and peripheral nodes are adjacent to the core nodes but not to other peripheral nodes”.[2]\nIf a token is to be described as being a central network we would see our graphs consist of core nodes, while a decentralized network would consist of periphery nodes.\nCore-periphery pairs are defined to have the properties of:\n\\[\nA^*=A^*_{ij}=(x_i+x_j-x_ix_j)\\delta(c_i,c_j)\n\\] We see \\(x_i=1\\) for core nodes and \\(x_i=0\\) for peripheral nodes. The index of the core-peripheral pair to which node \\(i\\) belongs to is represented by \\(c_i(1 \\leq c_i \\leq C)\\). The following properties are treated like axioms here.\n\n\nEvery core node is adjacent to every other core node.\n\n\nEvery core node is adjacent to all corresponding peripheral nodes.\n\n\nEvery peripheral node is not adjacent to any other peripheral node.\n\n\nLastly, there are no edges between different idealized core-periphery pairs. \\([3, 4]\\)\n\n\nWhen computing you want \\(c_i,x_i \\in(1 \\leq i \\leq N)\\) not be maximized comparatively between \\(A\\) and \\(A*\\). This is shown by: \\[Q^{cp}_{config} = \\frac{1}{2M} \\sum_{i=1}^N\\sum_{j=1}^N A_{ij}A_{ij}^* - Ε [\\frac{1}{2M} \\sum_{i=1}^N \\sum_{j=1}^{conf}(1-A_{ij}^*)]\\] Using a configuration model where the expected number of edges between nodes \\(i\\) and \\(j\\) can be represented by \\(Ε[A_{ij}^{conf}]=\\frac{d_id_j}{2M}\\)."
  },
  {
    "objectID": "Crypto.html#seeing-the-tokens-raw-form-of-a-network-for-the-months-of-june-through-august-3-continuous-months.",
    "href": "Crypto.html#seeing-the-tokens-raw-form-of-a-network-for-the-months-of-june-through-august-3-continuous-months.",
    "title": "Crypto",
    "section": "3.1 Seeing the token’s raw form of a network for the months of June through August, 3 continuous months.",
    "text": "3.1 Seeing the token’s raw form of a network for the months of June through August, 3 continuous months.\n\n\nCollecting matplotlib==3.5.1\n  Using cached matplotlib-3.5.1.tar.gz (35.3 MB)\n  Preparing metadata (setup.py): started\n  Preparing metadata (setup.py): finished with status 'done'\nRequirement already satisfied: cycler&gt;=0.10 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib==3.5.1) (0.11.0)\nRequirement already satisfied: fonttools&gt;=4.22.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib==3.5.1) (4.51.0)\nRequirement already satisfied: kiwisolver&gt;=1.0.1 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib==3.5.1) (1.4.4)\nRequirement already satisfied: numpy&gt;=1.17 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib==3.5.1) (1.26.4)\nRequirement already satisfied: packaging&gt;=20.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib==3.5.1) (24.1)\nRequirement already satisfied: pillow&gt;=6.2.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib==3.5.1) (10.4.0)\nRequirement already satisfied: pyparsing&gt;=2.2.1 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib==3.5.1) (3.1.2)\nRequirement already satisfied: python-dateutil&gt;=2.7 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib==3.5.1) (2.9.0.post0)\nRequirement already satisfied: six&gt;=1.5 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from python-dateutil&gt;=2.7-&gt;matplotlib==3.5.1) (1.16.0)\nBuilding wheels for collected packages: matplotlib\n  Building wheel for matplotlib (setup.py): started\n  Building wheel for matplotlib (setup.py): finished with status 'error'\n  Running setup.py clean for matplotlib\nFailed to build matplotlib\nRequirement already satisfied: scipy in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (1.16.0)\nRequirement already satisfied: networkx in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (3.5)\nRequirement already satisfied: numpy&lt;2.6,&gt;=1.25.2 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from scipy) (1.26.4)\nRequirement already satisfied: cpnet in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (0.0.21)\nRequirement already satisfied: networkx&gt;=2.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from cpnet) (3.5)\nRequirement already satisfied: numpy&gt;=1.16.5 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from cpnet) (1.26.4)\nRequirement already satisfied: simanneal&gt;=0.4.2 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from cpnet) (0.5.0)\nRequirement already satisfied: scipy&gt;=1.5.2 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from cpnet) (1.16.0)\nRequirement already satisfied: numba&gt;=0.50.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from cpnet) (0.60.0)\nRequirement already satisfied: joblib&gt;=0.16.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from cpnet) (1.4.2)\nRequirement already satisfied: plotly&gt;=4.10.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from cpnet) (5.24.1)\nRequirement already satisfied: seaborn&gt;=0.11.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from cpnet) (0.13.2)\nRequirement already satisfied: pandas&gt;=1.1.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from cpnet) (2.2.2)\nRequirement already satisfied: tqdm&gt;=4.49.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from cpnet) (4.66.5)\nRequirement already satisfied: llvmlite&lt;0.44,&gt;=0.43.0dev0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from numba&gt;=0.50.0-&gt;cpnet) (0.43.0)\nRequirement already satisfied: python-dateutil&gt;=2.8.2 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from pandas&gt;=1.1.0-&gt;cpnet) (2.9.0.post0)\nRequirement already satisfied: pytz&gt;=2020.1 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from pandas&gt;=1.1.0-&gt;cpnet) (2024.1)\nRequirement already satisfied: tzdata&gt;=2022.7 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from pandas&gt;=1.1.0-&gt;cpnet) (2023.3)\nRequirement already satisfied: tenacity&gt;=6.2.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from plotly&gt;=4.10.0-&gt;cpnet) (8.2.3)\nRequirement already satisfied: packaging in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from plotly&gt;=4.10.0-&gt;cpnet) (24.1)\nRequirement already satisfied: matplotlib!=3.6.1,&gt;=3.4 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from seaborn&gt;=0.11.0-&gt;cpnet) (3.9.2)\nRequirement already satisfied: colorama in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from tqdm&gt;=4.49.0-&gt;cpnet) (0.4.6)\nRequirement already satisfied: contourpy&gt;=1.0.1 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib!=3.6.1,&gt;=3.4-&gt;seaborn&gt;=0.11.0-&gt;cpnet) (1.2.0)\nRequirement already satisfied: cycler&gt;=0.10 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib!=3.6.1,&gt;=3.4-&gt;seaborn&gt;=0.11.0-&gt;cpnet) (0.11.0)\nRequirement already satisfied: fonttools&gt;=4.22.0 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib!=3.6.1,&gt;=3.4-&gt;seaborn&gt;=0.11.0-&gt;cpnet) (4.51.0)\nRequirement already satisfied: kiwisolver&gt;=1.3.1 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib!=3.6.1,&gt;=3.4-&gt;seaborn&gt;=0.11.0-&gt;cpnet) (1.4.4)\nRequirement already satisfied: pillow&gt;=8 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib!=3.6.1,&gt;=3.4-&gt;seaborn&gt;=0.11.0-&gt;cpnet) (10.4.0)\nRequirement already satisfied: pyparsing&gt;=2.3.1 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from matplotlib!=3.6.1,&gt;=3.4-&gt;seaborn&gt;=0.11.0-&gt;cpnet) (3.1.2)\nRequirement already satisfied: six&gt;=1.5 in c:\\users\\orin crouse\\anaconda3\\lib\\site-packages (from python-dateutil&gt;=2.8.2-&gt;pandas&gt;=1.1.0-&gt;cpnet) (1.16.0)\nThe libraries used are: matplotlib (verison 3.5.1), scipy, networkx, cpnet, numpy, pandas, os, time, zipfile, tqdm, \ncommunity.community_louvain, random, requests, json, and datetime.\n\n\nWARNING: Ignoring invalid distribution ~umpy (C:\\Users\\Orin Crouse\\anaconda3\\Lib\\site-packages)\n  error: subprocess-exited-with-error\n  \n  × python setup.py bdist_wheel did not run successfully.\n  │ exit code: 1\n  ╰─&gt; [606 lines of output]\n      C:\\Users\\Orin Crouse\\AppData\\Local\\Temp\\pip-install-6gkfgp2n\\matplotlib_9fcd9d02e799417c91b9e160892edc1a\\setup.py:70: SetuptoolsDeprecationWarning: The test command is disabled and references to it are deprecated.\n      !!\n      \n              ********************************************************************************\n              Please remove any references to `setuptools.command.test` in all supported versions of the affected package.\n      \n              This deprecation is overdue, please update your project and remove deprecated\n              calls to avoid build errors in the future.\n              ********************************************************************************\n      \n      !!\n        class NoopTestCommand(setuptools.command.test.test):\n      \n      Edit mplsetup.cfg to change the build options; suppress output with --quiet.\n      \n      BUILDING MATPLOTLIB\n            python: yes [3.12.7 | packaged by Anaconda, Inc. | (main, Oct  4 2024,\n                        13:17:27) [MSC v.1929 64 bit (AMD64)]]\n          platform: yes [win32]\n             tests: no  [skipping due to configuration]\n            macosx: no  [Mac OS-X only]\n      \n      C:\\Users\\Orin Crouse\\anaconda3\\Lib\\site-packages\\setuptools\\__init__.py:94: _DeprecatedInstaller: setuptools.installer and fetch_build_eggs are deprecated.\n      !!\n      \n              ********************************************************************************\n              Requirements should be satisfied by a PEP 517 installer.\n              If you are using pip, you can try `pip install --use-pep517`.\n              ********************************************************************************\n      \n      !!\n        dist.fetch_build_eggs(dist.setup_requires)\n      [07/15/25 22:40:00] WARNING  toml section missing       pyproject_reading.py:42\n                                   'pyproject.toml does not\n                                   contain a\n                                   tool.setuptools_scm\n                                   section'\n                                   Traceback (most recent\n                                   call last):\n                                     File \"c:\\users\\orin\n                                   crouse\\appdata\\local\\temp\\\n                                   pip-install-6gkfgp2n\\matpl\n                                   otlib_9fcd9d02e799417c91b9\n                                   e160892edc1a\\.eggs\\setupto\n                                   ols_scm-8.3.1-py3.12.egg\\s\n                                   etuptools_scm\\_integration\n                                   \\pyproject_reading.py\",\n                                   line 36, in read_pyproject\n                                       section =\n                                   defn.get(\"tool\",\n                                   {})[tool_name]\n                                                 ~~~~~~~~~~~~\n                                   ~~~~~~~~^^^^^^^^^^^\n                                   KeyError: 'setuptools_scm'\n      c:\\users\\orin crouse\\appdata\\local\\temp\\pip-install-6gkfgp2n\\matplotlib_9fcd9d02e799417c91b9e160892edc1a\\.eggs\\setuptools_scm-8.3.1-py3.12.egg\\setuptools_scm\\git.py:310: UserWarning: git archive did not support describe output\n        warnings.warn(\"git archive did not support describe output\")\n      C:\\Users\\Orin Crouse\\anaconda3\\Lib\\site-packages\\setuptools\\dist.py:655: SetuptoolsDeprecationWarning: The namespace_packages parameter is deprecated.\n      !!\n      \n              ********************************************************************************\n              Please replace its usage with implicit namespaces (PEP 420).\n      \n              See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages for details.\n              ********************************************************************************\n      \n      !!\n        ep.load()(self, ep.name, value)\n      running bdist_wheel\n      running build\n      running build_py\n      creating build\\lib.win-amd64-cpython-312\n      copying lib\\pylab.py -&gt; build\\lib.win-amd64-cpython-312\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\afm.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\animation.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\artist.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\axis.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\backend_bases.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\backend_managers.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\backend_tools.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\bezier.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\blocking_input.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\category.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\cm.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\collections.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\colorbar.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\colors.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\container.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\contour.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\dates.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\docstring.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\dviread.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\figure.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\fontconfig_pattern.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\font_manager.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\gridspec.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\hatch.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\image.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\legend.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\legend_handler.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\lines.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\markers.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\mathtext.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\mlab.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\offsetbox.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\patches.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\path.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\patheffects.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\pylab.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\pyplot.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\quiver.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\rcsetup.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\sankey.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\scale.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\spines.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\stackplot.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\streamplot.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\table.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\texmanager.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\text.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\textpath.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\ticker.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\tight_bbox.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\tight_layout.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\transforms.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\type1font.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\units.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\widgets.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_animation_data.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_blocking_input.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_cm.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_cm_listed.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_color_data.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_constrained_layout.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_enums.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_internal_utils.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_layoutgrid.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_mathtext.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_mathtext_data.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_pylab_helpers.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_text_helpers.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\_version.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      copying lib\\matplotlib\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\n      creating build\\lib.win-amd64-cpython-312\\mpl_toolkits\n      copying lib\\mpl_toolkits\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\axes\n      copying lib\\matplotlib\\axes\\_axes.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\axes\n      copying lib\\matplotlib\\axes\\_base.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\axes\n      copying lib\\matplotlib\\axes\\_secondary_axes.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\axes\n      copying lib\\matplotlib\\axes\\_subplots.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\axes\n      copying lib\\matplotlib\\axes\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\axes\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_agg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_cairo.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_gtk3.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_gtk3agg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_gtk3cairo.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_gtk4.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_gtk4agg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_gtk4cairo.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_macosx.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_mixed.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_nbagg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_pdf.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_pgf.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_ps.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_qt.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_qt5.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_qt5agg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_qt5cairo.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_qtagg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_qtcairo.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_svg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_template.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_tkagg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_tkcairo.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_webagg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_webagg_core.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_wx.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_wxagg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\backend_wxcairo.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\qt_compat.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\_backend_gtk.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\_backend_pdf_ps.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\_backend_tk.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      copying lib\\matplotlib\\backends\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\cbook\n      copying lib\\matplotlib\\cbook\\deprecation.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\cbook\n      copying lib\\matplotlib\\cbook\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\cbook\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\projections\n      copying lib\\matplotlib\\projections\\geo.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\projections\n      copying lib\\matplotlib\\projections\\polar.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\projections\n      copying lib\\matplotlib\\projections\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\projections\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\sphinxext\n      copying lib\\matplotlib\\sphinxext\\mathmpl.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\sphinxext\n      copying lib\\matplotlib\\sphinxext\\plot_directive.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\sphinxext\n      copying lib\\matplotlib\\sphinxext\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\sphinxext\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\style\n      copying lib\\matplotlib\\style\\core.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\style\n      copying lib\\matplotlib\\style\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\style\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\testing\n      copying lib\\matplotlib\\testing\\compare.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\n      copying lib\\matplotlib\\testing\\conftest.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\n      copying lib\\matplotlib\\testing\\decorators.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\n      copying lib\\matplotlib\\testing\\exceptions.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\n      copying lib\\matplotlib\\testing\\widgets.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\n      copying lib\\matplotlib\\testing\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\conftest.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_afm.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_agg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_agg_filter.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_animation.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_api.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_arrow_patches.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_artist.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_axes.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backends_interactive.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_bases.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_cairo.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_gtk3.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_macosx.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_nbagg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_pdf.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_pgf.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_ps.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_qt.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_svg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_tk.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_tools.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_backend_webagg.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_basic.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_bbox_tight.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_category.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_cbook.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_collections.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_colorbar.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_colors.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_compare_images.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_constrainedlayout.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_container.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_contour.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_cycles.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_dates.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_determinism.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_dviread.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_figure.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_fontconfig_pattern.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_font_manager.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_getattr.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_gridspec.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_image.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_legend.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_lines.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_marker.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_mathtext.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_matplotlib.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_mlab.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_offsetbox.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_patches.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_path.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_patheffects.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_pickle.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_png.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_polar.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_preprocess_data.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_pyplot.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_quiver.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_rcparams.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_sankey.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_scale.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_simplification.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_skew.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_sphinxext.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_spines.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_streamplot.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_style.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_subplots.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_table.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_testing.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_texmanager.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_text.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_ticker.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_tightlayout.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_transforms.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_triangulation.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_ttconv.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_type1font.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_units.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_usetex.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\test_widgets.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      copying lib\\matplotlib\\tests\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tests\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\tri\n      copying lib\\matplotlib\\tri\\triangulation.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tri\n      copying lib\\matplotlib\\tri\\tricontour.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tri\n      copying lib\\matplotlib\\tri\\trifinder.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tri\n      copying lib\\matplotlib\\tri\\triinterpolate.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tri\n      copying lib\\matplotlib\\tri\\tripcolor.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tri\n      copying lib\\matplotlib\\tri\\triplot.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tri\n      copying lib\\matplotlib\\tri\\trirefine.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tri\n      copying lib\\matplotlib\\tri\\tritools.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tri\n      copying lib\\matplotlib\\tri\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\tri\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\_api\n      copying lib\\matplotlib\\_api\\deprecation.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\_api\n      copying lib\\matplotlib\\_api\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\_api\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\qt_editor\n      copying lib\\matplotlib\\backends\\qt_editor\\figureoptions.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\qt_editor\n      copying lib\\matplotlib\\backends\\qt_editor\\_formlayout.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\qt_editor\n      copying lib\\matplotlib\\backends\\qt_editor\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\qt_editor\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\testing\\jpl_units\n      copying lib\\matplotlib\\testing\\jpl_units\\Duration.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\\jpl_units\n      copying lib\\matplotlib\\testing\\jpl_units\\Epoch.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\\jpl_units\n      copying lib\\matplotlib\\testing\\jpl_units\\EpochConverter.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\\jpl_units\n      copying lib\\matplotlib\\testing\\jpl_units\\StrConverter.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\\jpl_units\n      copying lib\\matplotlib\\testing\\jpl_units\\UnitDbl.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\\jpl_units\n      copying lib\\matplotlib\\testing\\jpl_units\\UnitDblConverter.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\\jpl_units\n      copying lib\\matplotlib\\testing\\jpl_units\\UnitDblFormatter.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\\jpl_units\n      copying lib\\matplotlib\\testing\\jpl_units\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\testing\\jpl_units\n      creating build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\anchored_artists.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\angle_helper.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\axes_divider.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\axes_grid.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\axes_rgb.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\axes_size.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\axislines.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\axisline_style.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\axis_artist.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\clip_path.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\floating_axes.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\grid_finder.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\grid_helper_curvelinear.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\inset_locator.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\parasite_axes.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      copying lib\\mpl_toolkits\\axes_grid\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid\n      creating build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid1\n      copying lib\\mpl_toolkits\\axes_grid1\\anchored_artists.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid1\n      copying lib\\mpl_toolkits\\axes_grid1\\axes_divider.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid1\n      copying lib\\mpl_toolkits\\axes_grid1\\axes_grid.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid1\n      copying lib\\mpl_toolkits\\axes_grid1\\axes_rgb.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid1\n      copying lib\\mpl_toolkits\\axes_grid1\\axes_size.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid1\n      copying lib\\mpl_toolkits\\axes_grid1\\inset_locator.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid1\n      copying lib\\mpl_toolkits\\axes_grid1\\mpl_axes.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid1\n      copying lib\\mpl_toolkits\\axes_grid1\\parasite_axes.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid1\n      copying lib\\mpl_toolkits\\axes_grid1\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axes_grid1\n      creating build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\angle_helper.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\axes_divider.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\axes_grid.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\axes_rgb.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\axislines.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\axisline_style.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\axis_artist.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\clip_path.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\floating_axes.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\grid_finder.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\grid_helper_curvelinear.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\parasite_axes.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      copying lib\\mpl_toolkits\\axisartist\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\axisartist\n      creating build\\lib.win-amd64-cpython-312\\mpl_toolkits\\mplot3d\n      copying lib\\mpl_toolkits\\mplot3d\\art3d.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\mplot3d\n      copying lib\\mpl_toolkits\\mplot3d\\axes3d.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\mplot3d\n      copying lib\\mpl_toolkits\\mplot3d\\axis3d.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\mplot3d\n      copying lib\\mpl_toolkits\\mplot3d\\proj3d.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\mplot3d\n      copying lib\\mpl_toolkits\\mplot3d\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\mplot3d\n      creating build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\conftest.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\test_axes_grid.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\test_axes_grid1.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\test_axisartist_angle_helper.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\test_axisartist_axislines.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\test_axisartist_axis_artist.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\test_axisartist_clip_path.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\test_axisartist_floating_axes.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\test_axisartist_grid_finder.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\test_axisartist_grid_helper_curvelinear.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\test_mplot3d.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      copying lib\\mpl_toolkits\\tests\\__init__.py -&gt; build\\lib.win-amd64-cpython-312\\mpl_toolkits\\tests\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\\css\n      copying lib\\matplotlib\\backends\\web_backend\\css\\boilerplate.css -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\\css\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSansMono.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\readme.txt -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Symbol.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\subplots_large.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXGeneralItalic.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\images\\hand.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\help.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pncri8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSansMono-Oblique.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\ptmbi8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\images\\back_large.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pagk8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\\js\n      copying lib\\matplotlib\\backends\\web_backend\\js\\mpl.js -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\\js\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\phvr8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\ptmr8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\phvro8an.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\images\\home.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-whitegrid.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\ptmri8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\cmb10.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\backends\\web_backend\\js\\mpl_tornado.js -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\\js\n      copying lib\\matplotlib\\mpl-data\\images\\forward.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\kpsewhich.lua -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\n      copying lib\\matplotlib\\mpl-data\\images\\zoom_to_rect.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pbkdi8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSerif.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\sample_data\\README.txt -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXSizFourSymBol.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\images\\help_large.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\help-symbolic.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pzcmi8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\phvr8an.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\sample_data\\eeg.dat -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-white.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSansMono-BoldOblique.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Helvetica-Bold.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\LICENSE_DEJAVU -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\cmr10.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\putri8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\plot_directive\n      copying lib\\matplotlib\\mpl-data\\plot_directive\\plot_directive.css -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\plot_directive\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\phvb8an.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pbkd8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-paper.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\sample_data\\percent_bachelors_degrees_women_usa.csv -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pncbi8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXSizTwoSymReg.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Courier-Bold.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\images\\home-symbolic.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\cmmi10.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\ZapfDingbats.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pncr8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\images\\matplotlib.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-dark-palette.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\images\\forward.pdf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXSizFourSymReg.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pplri8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\backends\\web_backend\\.prettierrc -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\n      copying lib\\matplotlib\\mpl-data\\images\\move_large.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\sample_data\\Minduka_Present_Blue_Pack.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pplbi8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\images\\filesave.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pbkl8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\images\\help.pdf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pcrr8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\putbi8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\backends\\web_backend\\ipython_inline_figure.html -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\n      copying lib\\matplotlib\\backends\\web_backend\\package.json -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\phvb8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Times-Italic.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\images\\move.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\stylelib\\grayscale.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSansMono-Bold.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\images\\forward.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\sample_data\\topobathy.npz -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-bright.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\ptmb8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\images\\matplotlib.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pagdo8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\images\\filesave_large.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\subplots-symbolic.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\cmtt10.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXSizOneSymReg.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pcrbo8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\sample_data\\logo2.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\sample_data\\msft.csv -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-pastel.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-dark.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSans-BoldOblique.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\phvlo8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\images\\back.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\subplots.pdf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\matplotlib_large.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\sample_data\\grace_hopper.jpg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\cmsy10.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\images\\forward_large.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\cmsy10.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Courier-BoldOblique.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\stylelib\\_classic_test_patch.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSansDisplay.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Times-Bold.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSans.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\backends\\web_backend\\.eslintrc.js -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\n      copying lib\\matplotlib\\mpl-data\\images\\filesave.pdf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXNonUniBolIta.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\images\\zoom_to_rect.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\subplots.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\stylelib\\dark_background.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\stylelib\\fivethirtyeight.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\images\\zoom_to_rect_large.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\filesave-symbolic.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\cmr10.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-muted.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Times-BoldItalic.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      creating build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\\axes_grid\n      copying lib\\matplotlib\\mpl-data\\sample_data\\axes_grid\\bivariate_normal.npy -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\\axes_grid\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pzdr.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\backends\\web_backend\\.prettierignore -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\phvro8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSerif-BoldItalic.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSerif-Bold.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXGeneralBol.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pcrro8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\images\\move-symbolic.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\hand.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\move.pdf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pagko8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pagd8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\backends\\web_backend\\all_figures.html -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\n      copying lib\\matplotlib\\backends\\web_backend\\single_figure.html -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-poster.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\stylelib\\_mpl-gallery-nogrid.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\putb8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\cmtt10.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\images\\zoom_to_rect-symbolic.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\matplotlib_128.ppm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\putr8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-ticks.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\cmss10.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pplr8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXGeneralBolIta.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXNonUniBol.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pcrb8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXNonUni.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\cmex10.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\backends\\web_backend\\css\\mpl.css -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\\css\n      copying lib\\matplotlib\\mpl-data\\sample_data\\jacksboro_fault_dem.npz -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pplb8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\stylelib\\Solarize_Light2.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSans-Oblique.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\images\\subplots.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSans-Bold.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\backends\\web_backend\\js\\nbagg_mpl.js -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\\js\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXGeneral.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\images\\filesave.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\LICENSE_STIX -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\phvbo8an.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\images\\back.pdf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-deep.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\stylelib\\classic.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\images\\home.pdf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-colorblind.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\stylelib\\fast.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-talk.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\cmmi10.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\phvl8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\images\\zoom_to_rect.pdf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXSizTwoSymBol.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\stylelib\\bmh.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pbkli8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\images\\home_large.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSerifDisplay.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Helvetica-Oblique.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\pncb8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\stylelib\\tableau-colorblind10.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\matplotlibrc -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\n      copying lib\\matplotlib\\mpl-data\\sample_data\\s1045.ima.gz -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-notebook.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXSizOneSymBol.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Helvetica.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\images\\back-symbolic.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\stylelib\\ggplot.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\images\\forward-symbolic.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\qt4_editor_options_large.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\hand.pdf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\backends\\web_backend\\css\\page.css -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\\css\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Helvetica-BoldOblique.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\stylelib\\_mpl-gallery.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\images\\back.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\qt4_editor_options.pdf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\backends\\web_backend\\nbagg_uat.ipynb -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Courier-Oblique.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\phvbo8a.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\backends\\web_backend\\css\\fbm.css -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\backends\\web_backend\\css\n      copying lib\\matplotlib\\mpl-data\\images\\home.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\move.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\stylelib\\seaborn-darkgrid.mplstyle -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\stylelib\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXNonUniIta.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\images\\help.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\qt4_editor_options.png -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\images\\matplotlib.pdf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Courier.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\DejaVuSerif-Italic.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXSizThreeSymReg.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\images\\qt4_editor_options.svg -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\images\n      copying lib\\matplotlib\\mpl-data\\sample_data\\membrane.dat -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\fonts\\afm\\psyr.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\afm\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXSizThreeSymBol.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\sample_data\\data_x_x2_x3.csv -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\cmex10.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\\Times-Roman.afm -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\pdfcorefonts\n      copying lib\\matplotlib\\mpl-data\\fonts\\ttf\\STIXSizFiveSymReg.ttf -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\fonts\\ttf\n      copying lib\\matplotlib\\mpl-data\\sample_data\\goog.npz -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      copying lib\\matplotlib\\mpl-data\\sample_data\\embedding_in_wx3.xrc -&gt; build\\lib.win-amd64-cpython-312\\matplotlib\\mpl-data\\sample_data\n      running build_ext\n      Extracting /project/freetype/freetype2/2.6.1/freetype-2.6.1.tar.gz\n      Building freetype in build\\freetype-2.6.1\n      error: Microsoft Visual C++ 14.0 or greater is required. Get it with \"Microsoft C++ Build Tools\": https://visualstudio.microsoft.com/visual-cpp-build-tools/\n      [end of output]\n  \n  note: This error originates from a subprocess, and is likely not a problem with pip.\n  ERROR: Failed building wheel for matplotlib\nERROR: ERROR: Failed to build installable wheels for some pyproject.toml based projects (matplotlib)\nWARNING: Ignoring invalid distribution ~umpy (C:\\Users\\Orin Crouse\\anaconda3\\Lib\\site-packages)\nWARNING: Ignoring invalid distribution ~umpy (C:\\Users\\Orin Crouse\\anaconda3\\Lib\\site-packages)\nWARNING: Ignoring invalid distribution ~umpy (C:\\Users\\Orin Crouse\\anaconda3\\Lib\\site-packages)\nWARNING: Ignoring invalid distribution ~umpy (C:\\Users\\Orin Crouse\\anaconda3\\Lib\\site-packages)\nWARNING: Ignoring invalid distribution ~umpy (C:\\Users\\Orin Crouse\\anaconda3\\Lib\\site-packages)\nWARNING: Ignoring invalid distribution ~umpy (C:\\Users\\Orin Crouse\\anaconda3\\Lib\\site-packages)\n\n\n\n\n11372 Number Transactions for the entire data set\n\n\n\n\n\n\n\n5485 Number Transactions for June\n\n\n\n\n\n\n\n\n\n\nConstruction of the continuous core-periphery structure using the Borgatti-Everett Algorithm.\n\n\n\n\n\nWe continue with the Kojaku-Masda Algorithm to see a similar approach, but better given colors….\n\n\n\n\n\n\n\nAverage Neighbors to Cores 1.0"
  },
  {
    "objectID": "Crypto.html#breakdown",
    "href": "Crypto.html#breakdown",
    "title": "Crypto",
    "section": "3.2 Breakdown",
    "text": "3.2 Breakdown\nNumber of Components: We expect a smaller number of componenets to indicate a more centralized network. The number of components is fairly random with an exception toward the beginning of the recorded data.\nGiant Component Size Ratio: A larger giant component size ratio indicates a more centralized network. In our data, the giant component ratio starts high (suggesting more centralization early on), then becomes random, similar to the number of components.\nModulatiry: A smaller modularity score suggests a more centralized network. Modularity for the Ether token starts low, but quickly rises, and stays fairly stable past day 15. This indicates a more centralized network in early days that becomes decentralized and stays decentralized after a couple of weeks. However, while the modularity for Euler settles around 0.6, the modularity for the AAVE token (found in the original paper) settles around 0.8 before dropping down to 0.7, a possible indication that AAVE is more decentralized than Euler.\nStandard Deviation of Degree Centrality: A higher standard deviation suggests a more centralized network. Standard deviation for Euler starts high but quickly falls by day five, where is stays steady. Like the modularity scores, this suggests a more centralized network early on that quickly becomes and stays decentralized."
  }
]